<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">scripts/modules/Selection.js | typester</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Typester">Typester</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#config">config</a><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-formatters">formatters</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Toolbar">Toolbar</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#containers">containers</a><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AppContainer">AppContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CanvasContainer">CanvasContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-FormatterContainer">FormatterContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UIContainer">UIContainer</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core">core</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Container">Container</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Context">Context</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Mediator">Mediator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Module">Module</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#modules">modules</a><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BaseFormatter">BaseFormatter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BlockFormatter">BlockFormatter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Canvas">Canvas</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ContentEditable">ContentEditable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Flyout">Flyout</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Formatter">Formatter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinkFormatter">LinkFormatter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ListFormatter">ListFormatter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Mouse">Mouse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Paste">Paste</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Selection">Selection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TextFormatter">TextFormatter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Toolbar">Toolbar</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils">utils</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-guid">guid</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DOM">DOM</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-browser">browser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-commands">commands</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-func">func</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-keycodes">keycodes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-pasteUtils">pasteUtils</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-zeroWidthSpace">zeroWidthSpace</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">scripts/modules/Selection.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// jshint strict: false

import Module from &apos;../core/Module&apos;;
import formattersConfig from &apos;../config/formatters&apos;;
import toolbarConfig from &apos;../config/toolbar&apos;;

import DOM from &apos;../utils/DOM&apos;;

/**
* @access protected
*/
const Selection = Module({
    name: &apos;Selection&apos;,
    props: {
        contextWindow: window,
        contextDocument: document,
        cachedSelection: null,
        cachedRange: null,
        pseudoSelection: null,
        silenceChanges: []
    },
    dom: {
        el: null
    },
    handlers: {
        requests: {
            &apos;selection:current&apos;: &apos;getCurrentSelection&apos;,
            &apos;selection:range&apos;: &apos;getCurrentRange&apos;,
            &apos;selection:anchornode&apos;: &apos;getAnchorNode&apos;,
            &apos;selection:commonancestor&apos;: &apos;getCommonAncestor&apos;,
            &apos;selection:closestblock&apos;: &apos;getClosestBlock&apos;,
            &apos;selection:rootelement&apos;: &apos;getRootElement&apos;,
            &apos;selection:range:clone&apos;: &apos;getRangeClone&apos;,
            &apos;selection:bounds&apos;: &apos;getSelectionBounds&apos;,
            &apos;selection:range:relative:toroot&apos;: &apos;getRangeRelativeToRoot&apos;,
            &apos;selection:in:or:contains&apos;: &apos;inOrContains&apos;,
            &apos;selection:range:coordinates&apos;: &apos;rangeCoordinates&apos;,
            &apos;selection:contains:node&apos;: &apos;containsNode&apos;,
            &apos;selection:spans:multiple:blocks&apos;: &apos;spansMultipleBlocks&apos;
        },

        commands: {
            &apos;selection:set:contextWindow&apos;: &apos;setContextWindow&apos;,
            &apos;selection:set:contextDocument&apos;: &apos;setContextDocument&apos;,
            &apos;selection:set:el&apos;: &apos;setRootElement&apos;,
            &apos;selection:expand:toroot&apos;: &apos;expandToRoot&apos;,
            &apos;selection:update:range&apos;: &apos;updateRange&apos;,
            &apos;selection:wrap:element&apos;: &apos;wrapElement&apos;,
            &apos;selection:wrap:content&apos;: &apos;wrapContent&apos;,
            &apos;selection:wrap:pseudo&apos;: &apos;wrapPseudoSelect&apos;,
            &apos;selection:select:pseudo&apos;: &apos;selectPseudo&apos;,
            &apos;selection:select:remove:pseudo&apos;: &apos;removePseudo&apos;,
            &apos;selection:collapse:tostart&apos;: &apos;collapseToStart&apos;,
            &apos;selection:reselect&apos;: &apos;reSelect&apos;,
            &apos;selection:select:contents&apos;: &apos;selectContents&apos;,
            &apos;selection:collapse:toend&apos;: &apos;collapseToEnd&apos;,
            &apos;selection:select:all&apos;: &apos;selectAll&apos;,
            &apos;selection:select:coordinates&apos;: &apos;selectByCoordinates&apos;,
            &apos;selection:ensure:text:only&apos; : &apos;ensureTextOnlySelection&apos;,
            &apos;selection:deselect&apos;: &apos;deSelect&apos;
        }
    },
    methods: {
        init () {
            this.bindDocumentEvents();
        },

        bindDocumentEvents () {
            const { contextDocument } = this.props;
            contextDocument.addEventListener(&apos;selectstart&apos;, this.handleSelectStart);
            contextDocument.addEventListener(&apos;selectionchange&apos;, this.handleSelectionChange);
        },

        unbindDocumentEvents () {
            const { contextDocument } = this.props;
            contextDocument.removeEventListener(&apos;selectstart&apos;, this.handleSelectStart);
            contextDocument.removeEventListener(&apos;selectionchange&apos;, this.handleSelectionChange);
        },

        setContextWindow (contextWindow) {
            const { props } = this;
            props.contextWindow = contextWindow;
        },

        setContextDocument (contextDocument) {
            const { props } = this;
            this.unbindDocumentEvents();
            props.contextDocument = contextDocument;
            this.bindDocumentEvents();
        },

        setRootElement (elem) {
            const { dom } = this;
            dom.el = [elem];
        },

        handleSelectStart (evnt) {
            const { mediator } = this;
            const { el } = this.dom;
            const anchorNode = this.getAnchorNode();

            if (DOM.isChildOf(anchorNode, el)) {
                mediator.emit(&apos;selection:start&apos;, evnt);
            }
        },

        handleSelectionChange (evnt) {
            const { mediator, props } = this;
            const { el } = this.dom;
            const anchorNode = this.getAnchorNode();

            if (DOM.isChildOf(anchorNode, el)) {
                this.cacheRange();
                if (!props.silenceChanges.length) {
                    mediator.emit(&apos;selection:change&apos;, evnt);
                } else {
                    props.silenceChanges.pop();
                }
            }
        },

        cacheRange () {
            const currentRange = this.getCurrentRange();
            this.props.cachedRange = currentRange.cloneRange();
        },

        getCurrentSelection () {
            const { contextWindow } = this.props;
            return contextWindow.getSelection();
        },

        validateSelection (selection) {
            const { dom } = this;
            return selection.anchorNode &amp;&amp; DOM.isChildOf(selection.anchorNode, dom.el);
        },

        getCurrentRange () {
            const { props } = this;
            const currentSelection = this.getCurrentSelection();
            let currentRange;

            if (this.validateSelection(currentSelection)) {
                currentRange = currentSelection.getRangeAt(0);
            } else if (props.cachedRange) {
                currentRange = props.cachedRange;
            } else {
                currentRange = document.createRange();
            }

            return currentRange;
        },

        getAnchorNode () {
            const currentSelection = this.getCurrentSelection();
            return currentSelection.anchorNode;
        },

        getCommonAncestor () {
            const currentSelection = this.getCurrentSelection();
            if (currentSelection.rangeCount &gt; 0) {
                const selectionRange = currentSelection.getRangeAt(0);
                return selectionRange.commonAncestorContainer;
            }
        },

        getClosestBlock () {
            const commonAncestor = this.getCommonAncestor();
            let closestBlockEl = null;
            let currentNode = commonAncestor;

            while (!closestBlockEl &amp;&amp; !this.isContentEditable(currentNode) &amp;&amp; currentNode) {
                if (currentNode.nodeType === Node.ELEMENT_NODE) {
                    let nodeTagName = currentNode.tagName.toLowerCase();
                    if (formattersConfig.base.blockElementNames.indexOf(nodeTagName) &gt; -1) {
                        closestBlockEl = currentNode;
                    } else {
                        currentNode = currentNode.parentNode;
                    }
                } else {
                    currentNode = currentNode.parentNode;
                }
            }

            return closestBlockEl;
        },

        getRootElement () {
            const { dom } = this;
            return dom.el[0];
        },

        getRangeClone () {
            const currentRange = this.getCurrentRange();
            return currentRange.cloneRange();
        },

        getRangeRelativeToRoot () {
            let {
                startContainer,
                startOffset,
                endContainer,
                endOffset
            } = this.getCurrentRange();
            let startCoordinates = [];
            let endCoordinates = [];
            let startRootChildIndex = 0;

            startCoordinates.unshift(startOffset);
            endCoordinates.unshift(endOffset);

            while (!this.isContentEditable(startContainer)) {
                if (this.isContentEditable(startContainer.parentNode)) {
                    startRootChildIndex = DOM.childIndex(startContainer);
                    startCoordinates.unshift(0);
                } else {
                    startCoordinates.unshift(DOM.childIndex(startContainer));
                }
                startContainer = startContainer.parentNode;
            }

            while (!this.isContentEditable(endContainer)) {
                if (this.isContentEditable(endContainer.parentNode)) {
                    endCoordinates.unshift(DOM.childIndex(endContainer) - startRootChildIndex);
                } else {
                    endCoordinates.unshift(DOM.childIndex(endContainer));
                }
                endContainer = endContainer.parentNode;
            }

            return {
                startCoordinates,
                endCoordinates
            };
        },

        rangeCoordinates () {
            this.ensureTextOnlySelection();

            let {
                startContainer,
                startOffset,
                endContainer,
                endOffset
            } = this.getCurrentRange();
            let startCoordinates = [];
            let endCoordinates = [];

            startCoordinates.unshift(startOffset);
            endCoordinates.unshift(endOffset);

            while (!this.isContentEditable(startContainer)) {
                startCoordinates.unshift(DOM.childIndex(startContainer));
                startContainer = startContainer.parentNode;
            }

            while (!this.isContentEditable(endContainer)) {
                endCoordinates.unshift(DOM.childIndex(endContainer));
                endContainer = endContainer.parentNode;
            }

            return {
                startCoordinates,
                endCoordinates
            };
        },

        inOrContains (selectors) {
            const { dom } = this;
            const rootEl = dom.el[0];
            const anchorNode = this.getAnchorNode();

            if (!rootEl.contains(anchorNode)) {
                return false;
            }

            const isIn = DOM.isIn(anchorNode, selectors, rootEl);

            if (isIn) {
                return isIn;
            }

            const currentRange = this.getCurrentRange();
            const rangeFrag = currentRange.cloneContents();
            let contains = false;

            if (rangeFrag.childNodes.length) {
                selectors.forEach(selector =&gt; {
                    contains = contains || rangeFrag.childNodes[0].nodeName === selector;
                });
            }

            return contains;
        },

        containsNode (node) {
            const currentSelection = this.getCurrentSelection();
            let { anchorNode, focusNode } = currentSelection;
            const selectionContainsNode = currentSelection.containsNode(node, true);

            if (!currentSelection.rangeCount) {
                return false;
            }

            if (selectionContainsNode) {
                return true;
            }

            if (anchorNode.nodeType !== Node.ELEMENT_NODE) {
                anchorNode = anchorNode.parentNode;
            }
            if (focusNode.nodeType !== Node.ELEMENT_NODE) {
                focusNode = focusNode.parentNode;
            }

            return anchorNode === node || focusNode === node;
        },

        expandToRoot (opts={}) {
            const currentRange = opts.range || this.getCurrentRange();
            let startRootNode = currentRange.startContainer;
            let endRootNode = currentRange.endContainer;
            const newRange = document.createRange();
            const startEqualsEnd = startRootNode === endRootNode;

            if (this.isContentEditable(startRootNode)) {
                return;
            }

            const getRootEl = (node) =&gt; {
                let currentNode = node;
                if (!this.isContentEditable(currentNode)) {
                    while (currentNode.parentNode &amp;&amp; !this.isContentEditable(currentNode.parentNode)) {
                        currentNode = currentNode.parentNode;
                    }
                }
                return currentNode;
            };

            startRootNode = getRootEl(startRootNode);
            endRootNode = startEqualsEnd ? startRootNode : getRootEl(endRootNode);

            if (opts.innerBounds) {
                newRange.setStartAfter(startRootNode);
                newRange.setEndBefore(endRootNode);
            } else {
                newRange.setStart(startRootNode, 0);
                newRange.setEndAfter(endRootNode);
            }

            this.updateRange(newRange, { silent:true });
        },

        wrapElement (elem, opts={}) {
            const currentRange = this.getCurrentRange();

            if (elem instanceof Array) {
                currentRange.setStartBefore(elem[0]);
                currentRange.setEndAfter(elem[elem.length - 1]);
            } else if (elem.nodeType === Node.ELEMENT_NODE) {
                currentRange.setStartBefore(elem);
                currentRange.setEndAfter(elem);
            }

            this.updateRange(currentRange, opts);
        },

        wrapContent () {
            const currentRange = this.getCurrentRange();
            const selectionRootEl = this.getRootElement();
            currentRange.selectNodeContents(selectionRootEl);
            this.updateRange(currentRange);
        },

        wrapPseudoSelect () {
            const { props } = this;
            const currentRange = this.getCurrentRange();

            const pseudoSelection = document.createElement(&apos;span&apos;);
            pseudoSelection.classList.add(&apos;typester-pseudo-selection&apos;);
            pseudoSelection.appendChild(currentRange.extractContents());
            currentRange.insertNode(pseudoSelection);

            props.pseudoSelection = pseudoSelection;
            this.wrapElement(pseudoSelection);
        },

        selectPseudo () {
            const { dom } = this;
            const unwrappedNodes = this.removePseudo();

            if (unwrappedNodes.length) {
                dom.el[0].focus();
                this.wrapElement(unwrappedNodes, { silent: true });
            }
        },

        removePseudo () {
            const { props } = this;
            let unwrappedNodes = [];

            if (
                props.pseudoSelection &amp;&amp;
                props.pseudoSelection.tagName
            ) {
                unwrappedNodes = DOM.unwrap(props.pseudoSelection);
                props.pseudoSelection = null;
            }

            return unwrappedNodes;
        },

        selectContents (node) {
            const newRange = document.createRange();

            if (node.childNodes.length) {
                newRange.selectNodeContents(node);
            } else {
                newRange.setStart(node, 0);
                newRange.collapse(true);
            }

            this.updateRange(newRange);
        },

        updateRange (range, opts={}) {
            const { mediator, props } = this;
            const currentSelection = this.getCurrentSelection();

            if (opts.silent) {
                props.silenceChanges.push(true); // silence removeAllRanges
                props.silenceChanges.push(true); // silence addRange
            }

            currentSelection.removeAllRanges();
            currentSelection.addRange(range);

            if (!opts.silent) {
                mediator.emit(&apos;selection:update&apos;);
            }
        },

        deSelect () {
            const currentSelection = this.getCurrentSelection();
            currentSelection.removeAllRanges();
        },

        isContentEditable (node) {
            return node &amp;&amp; node.nodeType === Node.ELEMENT_NODE &amp;&amp; node.hasAttribute(&apos;contenteditable&apos;);
        },

        getSelectionBounds () {
            const currentRange = this.getCurrentRange();
            const rangeRects = currentRange ? currentRange.getClientRects() : [];
            const rangeBoundingClientRect = currentRange ? currentRange.getBoundingClientRect() : null;

            let selectionBounds = {
                top: null,
                right: null,
                bottom: null,
                left: null,
                height: null,
                width: null,
                initialWidth: null,
                initialLeft: null
            };

            const setSelectionBoundary = function (rangeRect) {
                [&apos;top&apos;, &apos;left&apos;, &apos;bottom&apos;, &apos;right&apos;, &apos;height&apos;, &apos;width&apos;].forEach((rectKey) =&gt; {
                    if (!selectionBounds[rectKey]) {
                        selectionBounds[rectKey] = rangeRect[rectKey];
                    } else {
                        switch (rectKey) {
                        case &apos;top&apos;:
                        case &apos;left&apos;:
                            selectionBounds[rectKey] = Math.min(selectionBounds[rectKey], rangeRect[rectKey]);
                            break;
                        case &apos;bottom&apos;:
                        case &apos;right&apos;:
                        case &apos;height&apos;:
                        case &apos;width&apos;:
                            selectionBounds[rectKey] = Math.max(selectionBounds[rectKey], rangeRect[rectKey]);
                            break;
                        }
                    }
                });
            };

            const setInitialBoundary = function (rangeRect) {
                if (rangeBoundingClientRect) {
                    selectionBounds.initialLeft = rangeBoundingClientRect.left;
                    selectionBounds.initialWidth = rangeBoundingClientRect.width;
                } else if (rangeRect.top === selectionBounds.top) {
                    if (selectionBounds.initialLeft === null) {
                        selectionBounds.initialLeft = rangeRect.left;
                    } else {
                        selectionBounds.initialLeft = Math.min(rangeRect.left, selectionBounds.initialLeft);
                    }

                    if (selectionBounds.initialWidth === null) {
                        selectionBounds.initialWidth = rangeRect.width;
                    } else {
                        selectionBounds.initialWidth = Math.max(rangeRect.right - selectionBounds.initialLeft, selectionBounds.initialWidth);
                    }
                }
            };

            for (let i = 0; i &lt; rangeRects.length; i++) {
                setSelectionBoundary(rangeRects[i], i);
            }

            for (let i = 0; i &lt; rangeRects.length; i++) {
                setInitialBoundary(rangeRects[i], i);
            }

            return selectionBounds;
        },

        collapseToStart () {
            const currentRange = this.getCurrentRange();
            const newRange = document.createRange();

            newRange.setStart(currentRange.startContainer, currentRange.startOffset);
            newRange.setEnd(currentRange.startContainer, currentRange.startOffset);

            this.updateRange(newRange);
        },

        collapseToEnd () {
            const currentSelection = this.getCurrentSelection();
            currentSelection.collapseToEnd();
        },

        reSelect () {
            const { props } = this;
            if (props.cachedRange) {
                this.updateRange(props.cachedRange, { silent: true });
            }
        },

        selectAll (opts={}) {
            const { dom, props } = this;
            const { contextDocument } = props;
            const range = contextDocument.createRange();
            const rootElem = dom.el[0];

            if (opts.selector) {
                const elems = contextDocument.querySelectorAll(opts.selector);
                range.setStartBefore(elems[0]);
                range.setEndAfter(elems[elems.lenght - 1]);
            } else {
                range.setStart(rootElem, 0);
                range.setEndAfter(rootElem.lastChild);
            }

            this.updateRange(range);
        },

        selectByCoordinates (rangeCoordinates) {
            const { dom, props } = this;
            const { contextDocument } = props;
            const newRange = contextDocument.createRange();
            const startCoordinates = rangeCoordinates.startCoordinates.slice(0);
            const endCoordinates = rangeCoordinates.endCoordinates.slice(0);
            const startOffset = startCoordinates.pop();
            const endOffset = endCoordinates.pop();

            let startContainer = dom.el[0];
            let endContainer = dom.el[0];

            while (startCoordinates.length) {
                let startIndex = startCoordinates.shift();
                startContainer = startContainer.childNodes[startIndex];
            }

            while (endCoordinates.length) {
                let endIndex = endCoordinates.shift();
                endContainer = endContainer.childNodes[endIndex];
            }

            newRange.setStart(startContainer, startOffset);
            newRange.setEnd(endContainer, endOffset);

            this.updateRange(newRange);
        },

        ensureTextOnlySelection () {
            const { contextDocument } = this.props;
            const currentRange = this.getCurrentRange();
            const currentSelection = this.getCurrentSelection();
            const {
                startContainer,
                endContainer,
                commonAncestorContainer
            } = currentRange;

            if (
                currentSelection.isCollapsed ||
                (
                    startContainer.nodeType === Node.TEXT_NODE &amp;&amp;
                    endContainer.nodeType === Node.TEXT_NODE
                )
            ) {
                return;
            }

            const rangeString = currentRange.toString();

            let newRange = contextDocument.createRange();

            const walker = contextDocument.createTreeWalker(
                commonAncestorContainer,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let textNodes = [];
            while (walker.nextNode()) {
                textNodes.push(walker.currentNode);
            }

            const firstTextNode = textNodes[0];
            const lastTextNode = textNodes[textNodes.length - 1];

            newRange.setStart(firstTextNode, 0);
            newRange.setEnd(lastTextNode, lastTextNode.textContent.length);

            let currentNodeIndex = 0;
            let newStartOffset = 0;
            let currentTextNode = textNodes[currentNodeIndex];

            while (newRange.compareBoundaryPoints(Range.START_TO_START, currentRange) &lt; 0) {
                newStartOffset += 1;

                if (newStartOffset &gt; currentTextNode.textContent.length) {
                    currentNodeIndex += 1;
                    newStartOffset = 0;

                    if (currentNodeIndex &gt;= textNodes.length) {
                        break;
                    }
                    currentTextNode = textNodes[currentNodeIndex];
                }

                newRange.setStart(currentTextNode, newStartOffset);
            }

            let newEndOffset = newStartOffset;
            newRange.setEnd(currentTextNode, newEndOffset);

            while (newRange.compareBoundaryPoints(Range.END_TO_END, currentRange) &lt; 0) {
                newEndOffset += 1;
                if (newEndOffset &gt; currentTextNode.textContent.length) {
                    currentNodeIndex += 1;
                    newEndOffset = 0;

                    if (currentNodeIndex &gt;= textNodes.length) {
                        break;
                    }
                    currentTextNode = textNodes[currentNodeIndex];
                }

                newRange.setEnd(currentTextNode, newEndOffset);
            }

            if (newRange.toString() === rangeString) {
                this.updateRange(newRange, { silent: true });
            }
        }
    },

    spansMultipleBlocks () {
        const {
            anchorNode,
            focusNode
        } = this.getCurrentSelection();

        const rootElem = this.getRootElement();
        const blockTagNames = toolbarConfig.getBlockTags();

        const anchorBlock = DOM.getClosestInArray(anchorNode, blockTagNames, rootElem);
        const focusBlock = DOM.getClosestInArray(focusNode, blockTagNames, rootElem);

        return anchorBlock !== focusBlock;
    }
});

export default Selection;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/ListFormatter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/ListFormatter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// jshint strict: false

import Module from '../core/Module';
import commands from '../utils/commands';
import DOM from '../utils/DOM';

/**
* @access protected
*/
const ListFormatter = Module({
    name: 'ListFormatter',
    props: {},
    dom: {},
    handlers: {
        requests: {},
        commands: {
            'format:list': 'formatList',
            'format:list:cleanup': 'cleanupListDOM'
        },
        events: {
            'contenteditable:tab:down': 'handleTabDown',
            'contenteditable:tab:up': 'handleTabUp'
        }
    },
    methods: {
        init () {},
        formatList (opts) {
            this.preProcess(opts);
            this.process(opts);
            this.commit(opts);
        },

        preProcess () {
            const { mediator } = this;
            mediator.exec('format:export:to:canvas');
        },

        process (opts) {
            const { mediator } = this;
            const canvasDoc = mediator.get('canvas:document');
            let toggle = false;

            mediator.exec('canvas:cache:selection');
            switch (opts.style) {
            case 'ordered':
                toggle = mediator.get('selection:in:or:contains', ['OL']);
                if (toggle) {
                    // this.prepListItemsForToggle();
                    // while (mediator.get('canvas:selection:in:or:contains', ['OL'])) {
                    //     commands.exec('outdent', null, canvasDoc);
                    // }
                    // commands.exec('insertOrderedList', null, canvasDoc);
                    // return;
                } else if (mediator.get('selection:in:or:contains', ['UL'])) {
                    commands.exec('insertUnorderedList', null, canvasDoc);
                }
                commands.exec('insertOrderedList', null, canvasDoc);
                break;
            case 'unordered':
                toggle = mediator.get('selection:in:or:contains', ['UL']);
                if (toggle) {
                    // this.prepListItemsForToggle();
                    // while (mediator.get('canvas:selection:in:or:contains', ['UL'])) {
                    //     commands.exec('outdent', null, canvasDoc);
                    // }
                    // commands.exec('insertUnorderedList', null, canvasDoc);
                    // return;
                }
                if (mediator.get('selection:in:or:contains', ['OL'])) {
                    commands.exec('insertOrderedList', null, canvasDoc);
                }
                commands.exec('insertUnorderedList', null, canvasDoc);
                break;
            case 'outdent':
                commands.exec('outdent', null, canvasDoc);
                break;
            case 'indent':
                commands.exec('indent', null, canvasDoc);
                break;
            }

            if (toggle) {
                // mediator.exec('canvas:select:cachedSelection');
                this.postProcessToggle(opts);
            } else {
                mediator.exec('canvas:select:ensure:offsets');
            }

            // mediator.exec('canvas:select:cachedSelection');
        },

        commit () {
            const { mediator, cleanupListDOM } = this;
            mediator.exec('format:import:from:canvas', {
                importFilter: cleanupListDOM
            });
        },

        handleTabDown (evnt) {
            const { mediator } = this;
            const isInList = mediator.get('selection:in:or:contains', ['UL', 'OL']);

            if (isInList) {
                evnt.preventDefault();
            }
        },

        handleTabUp (evnt) {
            const { mediator } = this;
            const isInList = mediator.get('selection:in:or:contains', ['UL', 'OL']);


            if (isInList) {
                evnt.preventDefault();

                if (evnt.shiftKey) {
                    // this.formatList({ style: 'outdent' });
                } else {
                    // this.formatList({ style: 'indent' });
                }
            }
        },

        prepListItemsForToggle () {
            const { mediator } = this;

            const canvasDoc = mediator.get('canvas:document');
            const canvasBody = mediator.get('canvas:body');

            const {
                anchorNode,
                focusNode,
            } = mediator.get('canvas:selection');

            const anchorLiNode = DOM.getClosest(anchorNode, 'LI', canvasBody);
            const focusLiNode = DOM.getClosest(focusNode, 'LI', canvasBody);

            mediator.exec('canvas:cache:selection');

            let selectedLiNodes = [anchorLiNode];
            let nextLiNode = anchorLiNode.nextSibling;
            while (nextLiNode &amp;&amp; nextLiNode !== focusLiNode) {
                selectedLiNodes.push(nextLiNode);
                nextLiNode = nextLiNode.nextSibling;
            }
            selectedLiNodes.push(focusLiNode);

            selectedLiNodes.forEach((selectedLiNode) => {
                let contentWrapper = canvasDoc.createElement('span');
                selectedLiNode.appendChild(contentWrapper);
                while (selectedLiNode.firstChild !== contentWrapper) {
                    contentWrapper.appendChild(selectedLiNode.firstChild);
                }
            });

            mediator.exec('canvas:select:cachedSelection');

            return;
            // const canvasBody = mediator.get('canvas:body');
            // const canvasDoc = mediator.get('canvas:document');
            //
            // let rootBlock = anchorNode;
            // while(rootBlock.parentNode !== canvasBody) {
            //     rootBlock = rootBlock.parentNode;
            // }
            //
            // const liNodes = rootBlock.querySelectorAll('li');
            // liNodes.forEach((liNode) => {
            //     let pNode = canvasDoc.createElement('span');
            //     liNode.appendChild(pNode);
            //     while (liNode.firstChild !== pNode) {
            //         pNode.appendChild(liNode.firstChild);
            //     }
            // });
        },

        postProcessToggle () {
            const { mediator } = this;
            // return;

            const canvasDoc = mediator.get('canvas:document');
            const canvasBody = mediator.get('canvas:body');

            mediator.exec('canvas:cache:selection');

            const {
                anchorNode,
                focusNode
            } = mediator.get('canvas:selection');

            const walkToRoot = function (node) {
                let rootNode = node;
                while ( rootNode.parentNode !== canvasBody ) {
                    rootNode = rootNode.parentNode;
                }
                return rootNode;
            };

            const anchorRootNode = walkToRoot(anchorNode);
            const focusRootNode = walkToRoot(focusNode);

            let currentNode = anchorRootNode;
            let currentParagraph;

            const createParagraph = function () {
                currentParagraph = canvasDoc.createElement('p');
                DOM.insertBefore(currentParagraph, currentNode);
            };

            const handleBrNode = function (brNode) {
                createParagraph();
                currentNode = brNode.nextSibling;
                DOM.removeNode(brNode);
            };

            const handleDivNode = function (divNode) {
                createParagraph();
                currentNode = divNode.nextSibling;
                while (divNode.firstChild) {
                    currentParagraph.appendChild(divNode.firstChild);
                }
                DOM.removeNode(divNode);
            };

            createParagraph();

            while (currentNode !== focusRootNode) {
                if (currentNode.nodeName === 'BR') {
                    handleBrNode(currentNode);
                } else if (currentNode.nodeName === 'DIV') {
                    handleDivNode(currentNode);
                } else {
                    let orphanedNode = currentNode;
                    currentNode = currentNode.nextSibling;
                    currentParagraph.appendChild(orphanedNode);
                }
            }

            if (focusRootNode.nodeName === 'DIV') {
                handleDivNode(focusRootNode);
            } else {
                currentParagraph.appendChild(focusRootNode);
            }

            mediator.exec('canvas:select:cachedSelection');
        },

        cleanupListDOM (rootElem) {
            const listContainers = rootElem.querySelectorAll('OL, UL');

            for (let i = listContainers.length - 1; i >= 0; i--) {
                let listContainer = listContainers[i];
                if (['OL', 'UL'].indexOf(listContainer.parentNode.nodeName) > -1) {
                    if (listContainer.previousSibling) {
                        if (listContainer.previousSibling.nodeName === 'LI') {
                            listContainer.previousSibling.appendChild(listContainer);
                        }

                        if (['OL', 'UL'].indexOf(listContainer.previousSibling.nodeName) > -1) {
                            for (let j = 0; j &lt;= listContainer.childNodes.length; j++) {
                                listContainer.previousSibling.appendChild(listContainer.childNodes[j]);
                            }
                            DOM.removeNode(listContainer);
                        }
                    } else {
                        DOM.unwrap(listContainer);
                    }
                } else {
                    while (listContainer.parentNode &amp;&amp; listContainer.parentNode !== rootElem &amp;&amp; ['LI'].indexOf(listContainer.parentNode.nodeName) &lt; 0) {
                        DOM.insertBefore(listContainer, listContainer.parentNode);
                    }
                }
            }

            const nestedListItems = rootElem.querySelectorAll('LI > LI');
            for (let i = nestedListItems.length - 1; i >= 0; i--) {
                let nestedListItem = nestedListItems[i];
                DOM.insertAfter(nestedListItem, nestedListItem.parentNode);
            }
        }
    }
});

export default ListFormatter;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-containers_AppContainer.html">containers/AppContainer</a></li><li><a href="module-containers_CanvasContainer.html">containers/CanvasContainer</a></li><li><a href="module-containers_FormatterContainer.html">containers/FormatterContainer</a></li><li><a href="module-containers_UIContainer.html">containers/UIContainer</a></li><li><a href="module-core_Container.html">core/Container</a></li><li><a href="module-core_Context.html">core/Context</a></li><li><a href="module-core_Mediator.html">core/Mediator</a></li><li><a href="module-modules_ContentEditable.html">modules/ContentEditable</a></li><li><a href="module-modules_Selection.html">modules/Selection</a></li></ul><h3>Classes</h3><ul><li><a href="module-containers_AppContainer-AppContainer.html">AppContainer</a></li><li><a href="module-containers_CanvasContainer-CanvasContainer.html">CanvasContainer</a></li><li><a href="module-containers_FormatterContainer-FormatterContainer.html">FormatterContainer</a></li><li><a href="module-containers_UIContainer-UIContainer.html">UIContainer</a></li><li><a href="module-core_Context-Context.html">Context</a></li><li><a href="module-core_Mediator-Mediator.html">Mediator</a></li><li><a href="module-modules_ContentEditable-ContentEditable.html">ContentEditable</a></li><li><a href="module-modules_Selection-Selection.html">Selection</a></li></ul><h3>Events</h3><ul><li><a href="module-modules_ContentEditable.html#~event:contenteditable:focus">contenteditable:focus</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-core_Mediator-Mediator-requests.html">requests</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BaseFormatter">BaseFormatter</a></li><li><a href="global.html#BlockFormatter">BlockFormatter</a></li><li><a href="global.html#browser">browser</a></li><li><a href="global.html#Canvas">Canvas</a></li><li><a href="global.html#commands">commands</a></li><li><a href="global.html#DOM">DOM</a></li><li><a href="global.html#Flyout">Flyout</a></li><li><a href="global.html#Formatter">Formatter</a></li><li><a href="global.html#formatters">formatters</a></li><li><a href="global.html#func">func</a></li><li><a href="global.html#guid">guid</a></li><li><a href="global.html#keycodes">keycodes</a></li><li><a href="global.html#LinkFormatter">LinkFormatter</a></li><li><a href="global.html#ListFormatter">ListFormatter</a></li><li><a href="global.html#Module">Module</a></li><li><a href="global.html#Mouse">Mouse</a></li><li><a href="global.html#Paste">Paste</a></li><li><a href="global.html#pasteUtils">pasteUtils</a></li><li><a href="global.html#TextFormatter">TextFormatter</a></li><li><a href="global.html#Toolbar">Toolbar</a></li><li><a href="global.html#Typester">Typester</a></li><li><a href="global.html#zeroWidthSpace">zeroWidthSpace</a></li><li><a href="global.html#zeroWidthSpaceEntity">zeroWidthSpaceEntity</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Jan 09 2018 21:24:57 GMT+0200 (SAST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

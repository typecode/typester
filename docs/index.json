[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "scripts/.external-ecmascript.js",
    "static": true,
    "longname": "scripts/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "scripts/config/config.js",
    "content": "/**\n* @access protected\n*/\nexport default {\n    commands: {\n        bold: {\n            tags: ['B', 'STRONG'],\n            togglable: true\n        },\n        italic: {\n            tags: ['I'],\n            togglable: true\n        },\n        formatBlock: {\n            tags: [\n                'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P',\n                'BLOCKQUOTE'\n            ],\n            unwrapIfIn: [\n                'bold',\n                'formatBlock',\n                'insertOrderedList',\n                'insertUnorderedList'\n            ]\n        },\n        insertOrderedList: {\n            tags: ['OL', 'LI'],\n            unwrapIfIn: [\n                'formatBlock'\n            ],\n            togglable: true\n        },\n        insertUnorderedList: {\n            tags: ['UL', 'LI'],\n            unwrapIfIn: [\n                'formatBlock'\n            ],\n            togglable: true\n        },\n        createLink: {\n            tags: ['A']\n        }\n    },\n    defaultBlock: 'P',\n    paste: {\n        invalidTags: ['SCRIPT', 'LINK', 'IMG']\n    },\n    global: {},\n    toolbar: {},\n    contentEditable: {}\n};\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/config/config.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "file",
    "name": "scripts/config/formatters.js",
    "content": "/**\n* @access protected\n*/\nconst formatters = {\n    base: {\n        blockElementNames: [\n            'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ol', 'ul', 'li', 'p', 'pre',\n            'address', 'article', 'aside', 'canvas', 'dd', 'div', 'dl', 'dt',\n            'fieldset', 'figcaption', 'figure', 'footer', 'form', 'header', 'hgroup',\n            'hr', 'main', 'nav', 'noscript', 'output', 'section', 'table', 'tfoot',\n            'video'\n        ]\n    },\n\n    text: {\n        nodeLevel: Node.TEXT_NODE,\n        changeLevel: {\n            DOM: true,\n            styles: false\n        }\n    },\n\n    paragraph: {\n        nodeLevel: Node.ELEMENT_NODE,\n        changeLevel: {\n            DOM: false,\n            styles: true\n        }\n    },\n\n    list: {\n        nodeLevel: Node.ELEMENT_NODE,\n        changeLevel: {\n            DOM: true,\n            styles: false\n        },\n        rootTags: ['ol', 'ul'],\n        methods: {\n            orderedlist: {\n                rootTag: 'ol',\n                tags: ['ol', 'li']\n            },\n            unorderedlist: {\n                rootTag: 'ul',\n                tags: ['ul', 'li']\n            }\n        }\n    },\n\n    block: {\n        defaultElement: 'p',\n        baseElement: 'div',\n        nodeLevel: Node.ELEMENT_NODE,\n        changeLevel: {\n            DOM: true,\n            styles: false\n        }\n    }\n};\n\nexport default formatters;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/config/formatters.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 50,
    "kind": "variable",
    "name": "formatters",
    "memberof": "scripts/config/formatters.js",
    "static": true,
    "longname": "scripts/config/formatters.js~formatters",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/config/formatters.js",
    "importStyle": "formatters",
    "description": "",
    "lineNumber": 4,
    "type": {
      "types": [
        "{\"base\": *, \"text\": *, \"paragraph\": *, \"list\": *, \"block\": *}"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "file",
    "name": "scripts/config/toolbar.js",
    "content": "// jshint strict: false\n\nimport linkIcon from '../../templates/icons/link.html';\nimport orderedlistIcon from '../../templates/icons/orderedlist.html';\nimport unorderedlistIcon from '../../templates/icons/unorderedlist.html';\nimport quoteIcon from '../../templates/icons/quote.html';\n\n/**\n* @access protected\n*/\nconst Toolbar = {\n    buttons: ['bold', 'italic', 'h1', 'h2', 'orderedlist', 'unorderedlist', 'quote', 'link'],\n    preventNewlineDefault: ['ul', 'ol'],\n    blockTags: ['P'],\n    validTags: ['P'],\n    listTags: [],\n    getValidTags () {\n        let { validTags } = Toolbar;\n\n        if ( validTags.length === 1 ) {\n            Toolbar.parseForTagLists();\n        }\n\n        return Toolbar.validTags;\n    },\n    getBlockTags () {\n        let { blockTags } = Toolbar;\n\n        if ( blockTags.length === 1 ) {\n            Toolbar.parseForTagLists();\n        }\n\n        return Toolbar.blockTags;\n\n    },\n    getListTags () {\n        let { listTags } = Toolbar;\n\n        if ( listTags.length === 0 ) {\n            Toolbar.parseForTagLists();\n        }\n\n        return Toolbar.listTags;\n    },\n    parseForTagLists () {\n        let {\n            validTags,\n            blockTags,\n            listTags\n        } = Toolbar;\n\n        Toolbar.buttons.forEach((buttonKey) => {\n            let buttonConfig = Toolbar.buttonConfigs[buttonKey];\n            let configValidTags = buttonConfig.opts.validTags;\n\n            validTags = validTags.concat(configValidTags);\n\n            switch (buttonConfig.formatter) {\n            case 'block':\n                blockTags = blockTags.concat(configValidTags);\n                break;\n            case 'list':\n                listTags = listTags.concat(configValidTags);\n                break;\n            }\n        });\n\n        Toolbar.validTags = validTags;\n        Toolbar.blockTags = blockTags;\n        Toolbar.listTags  = listTags;\n    },\n    buttonConfigs: {\n        // Text styles\n        bold: {\n            formatter: 'text',\n            opts: {\n                style: 'bold',\n                rootEl: 'b',\n                validTags: ['B', 'STRONG']\n            },\n            content: '<b>B</b>',\n            disabledIn: ['H1', 'H2', 'BLOCKQUOTE'],\n            activeIn: ['B']\n        },\n\n        italic: {\n            formatter: 'text',\n            opts: {\n                style: 'italic',\n                rootEl: 'i',\n                validTags: ['I']\n            },\n            content: '<i>I</i>',\n            activeIn: ['I']\n        },\n\n        underline: {\n            formatter: 'text:underline',\n            content: '<u>U</u>'\n        },\n\n        strikethrough: {\n            formatter: 'text:strikethrough',\n            content: '<s>A</s>'\n        },\n\n        superscript: {\n            formatter: 'text:superscript',\n            content: 'x<sup>1</sup>'\n        },\n\n        subscript: {\n            formatter: 'text:subscript',\n            content: 'x<sub>1</sub>'\n        },\n\n        // Paragraph styles\n        justifyCenter: {\n            formatter: 'paragraph:justifyCenter'\n        },\n\n        justifyFull: {\n            formatter: 'paragraph:justifyFull'\n        },\n\n        justifyLeft: {\n            formatter: 'paragraph:justifyLeft'\n        },\n\n        justifyRight: {\n            formatter: 'paragraph:justifyRight'\n        },\n\n        indent: {\n            formatter: 'paragraph:indent'\n        },\n\n        outdent: {\n            formatter: 'paragraph:outdent'\n        },\n\n        // Lists\n        orderedlist: {\n            formatter: 'list',\n            content: orderedlistIcon({}, {}, true),\n            opts: {\n                style: 'ordered',\n                validTags: ['OL', 'LI']\n            },\n            activeIn: ['OL']\n        },\n\n        unorderedlist: {\n            formatter: 'list',\n            content: unorderedlistIcon({}, {}, true),\n            opts: {\n                style: 'unordered',\n                validTags: ['UL', 'LI']\n            },\n            activeIn: ['UL']\n        },\n\n        // Block level elements\n        quote: {\n            formatter: 'block',\n            content: quoteIcon({}, {}, true),\n            opts: {\n                style: 'BLOCKQUOTE',\n                validTags: ['BLOCKQUOTE']\n            },\n            activeIn: ['BLOCKQUOTE'],\n            disabledIn (mediator) {\n                let disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);\n                disabled = disabled || mediator.get('selection:spans:multiple:blocks');\n                return disabled;\n            },\n            toggles: true\n        },\n\n        pre: {\n            formatter: 'block',\n            opts: {\n                style: 'PRE'\n            },\n            disabledIn (mediator) {\n                let disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);\n                disabled = disabled || mediator.get('selection:spans:multiple:blocks');\n                return disabled;\n            },\n            content: 'PRE'\n        },\n\n        h1: {\n            formatter: 'block',\n            opts: {\n                style: 'H1',\n                validTags: ['H1']\n            },\n            content: 'H1',\n            activeIn: ['H1'],\n            disabledIn (mediator) {\n                let disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);\n                disabled = disabled || mediator.get('selection:spans:multiple:blocks');\n                return disabled;\n            },\n            toggles: true\n        },\n\n        h2: {\n            formatter: 'block',\n            opts: {\n                style: 'H2',\n                validTags: ['H2']\n            },\n            content: 'H2',\n            activeIn: ['H2'],\n            disabledIn (mediator) {\n                let disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);\n                disabled = disabled || mediator.get('selection:spans:multiple:blocks');\n                return disabled;\n            },\n            toggles: true\n        },\n\n        h3: {\n            formatter: 'block',\n            opts: {\n                style: 'H3',\n                validTags: ['H3']\n            },\n            content: 'H3',\n            activeIn: ['H3'],\n            disabledIn (mediator) {\n                let disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);\n                disabled = disabled || mediator.get('selection:spans:multiple:blocks');\n                return disabled;\n            },\n            toggles: true\n        },\n\n        h4: {\n            formatter: 'block',\n            opts: {\n                style: 'H4',\n                validTags: ['H4']\n            },\n            content: 'H4',\n            activeIn: ['H4'],\n            disabledIn (mediator) {\n                let disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);\n                disabled = disabled || mediator.get('selection:spans:multiple:blocks');\n                return disabled;\n            },\n            toggles: true\n        },\n\n        h5: {\n            formatter: 'block',\n            opts: {\n                style: 'H5',\n                validTags: ['H5']\n            },\n            content: 'H5',\n            activeIn: ['H5'],\n            disabledIn (mediator) {\n                let disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);\n                disabled = disabled || mediator.get('selection:spans:multiple:blocks');\n                return disabled;\n            },\n            toggles: true\n        },\n\n        h6: {\n            formatter: 'block',\n            opts: {\n                style: 'H6',\n                validTags: ['H6']\n            },\n            content: 'H6',\n            activeIn: ['H6'],\n            disabledIn (mediator) {\n                let disabled = mediator.get('selection:in:or:contains', ['OL', 'UL']);\n                disabled = disabled || mediator.get('selection:spans:multiple:blocks');\n                return disabled;\n            },\n            toggles: true\n        },\n\n        // Link\n        link: {\n            formatter: 'link',\n            opts: {\n                validTags: ['A']\n            },\n            content: linkIcon({}, {}, true),\n            activeIn: ['A'],\n            disabledIn (mediator) {\n                let disabled = mediator.get('selection:spans:multiple:blocks');\n                return disabled;\n            }\n        }\n    }\n};\n\nexport default Toolbar;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/config/toolbar.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 52,
    "kind": "variable",
    "name": "Toolbar",
    "memberof": "scripts/config/toolbar.js",
    "static": true,
    "longname": "scripts/config/toolbar.js~Toolbar",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/config/toolbar.js",
    "importStyle": "Toolbar",
    "description": "",
    "lineNumber": 11,
    "type": {
      "types": [
        "{\"buttons\": *, \"preventNewlineDefault\": *, \"blockTags\": *, \"validTags\": *, \"listTags\": *, \"getValidTags\": function, \"getBlockTags\": function, \"getListTags\": function, \"parseForTagLists\": function, \"buttonConfigs\": *}"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "file",
    "name": "scripts/containers/AppContainer.js",
    "content": "// jshint strict: false\n\nimport Container from '../core/Container';\n\nimport UIContainer from '../containers/UIContainer';\nimport FormatterContainer from '../containers/FormatterContainer';\nimport CanvasContainer from '../containers/CanvasContainer';\n\nimport ContentEditable from '../modules/ContentEditable';\nimport Selection from '../modules/Selection';\n\nlet uiContainer, formatterContainer, canvasContainer;\n\n\n/**\n * ### AppContainer\n * The top most container for the Typester app stack. This\n * container sets up the {@link FormatterContainer}, {@link UIContainer},\n * and {@link CanvasContainer} containers which in return setup various\n * modules that make up the app stack.\n *\n * @access protected\n * @param  {object} opts={} instance options\n * @param  {element} opts.dom.el The dom element to be the canvas for Typester\n * @return {appContainer} AppContainer instance\n *\n * @example\n * new AppContainer({\n *   dom: {\n *     el: domElement\n *   }\n * });\n */\nconst AppContainer = Container({\n    name: 'AppContainer',\n    modules: [\n        {\n            class: ContentEditable\n        },\n        {\n            class: Selection\n        }\n    ],\n    handlers: {\n        events: {\n            'contenteditable:focus': 'handleFocus',\n            'contenteditable:blur': 'handleBlur'\n        }\n    },\n    methods: {\n/**\n * AppContainer:setup() - setup the child containers used to group other app components\n */\n        setup () {\n            const { mediator } = this;\n            formatterContainer = formatterContainer || new FormatterContainer({ mediator });\n            uiContainer = uiContainer || new UIContainer({ mediator });\n            canvasContainer = canvasContainer || new CanvasContainer({ mediator });\n        },\n        init () {\n        },\n\n        handleFocus () {\n            const { mediator } = this;\n            uiContainer.setMediatorParent(mediator);\n            formatterContainer.setMediatorParent(mediator);\n            canvasContainer.setMediatorParent(mediator);\n        },\n\n        handleBlur () {\n            // Should the container require to do anything in particular here\n        }\n    }\n});\n\nexport default AppContainer;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/containers/AppContainer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 54,
    "kind": "variable",
    "name": "AppContainer",
    "memberof": "scripts/containers/AppContainer.js",
    "static": true,
    "longname": "scripts/containers/AppContainer.js~AppContainer",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/containers/AppContainer.js",
    "importStyle": "AppContainer",
    "description": "### AppContainer\nThe top most container for the Typester app stack. This\ncontainer sets up the {@link FormatterContainer}, {@link UIContainer},\nand {@link CanvasContainer} containers which in return setup various\nmodules that make up the app stack.",
    "examples": [
      "new AppContainer({\n  dom: {\n    el: domElement\n  }\n});"
    ],
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "opts",
        "description": "instance options"
      },
      {
        "nullable": null,
        "types": [
          "element"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.dom.el",
        "description": "The dom element to be the canvas for Typester"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "appContainer"
      ],
      "spread": false,
      "description": "AppContainer instance"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "file",
    "name": "scripts/containers/CanvasContainer.js",
    "content": "// jshint strict: false\n\nimport Container from '../core/Container';\nimport Selection from '../modules/Selection';\nimport Canvas from '../modules/Canvas';\n\n/**\n* @access protected\n*/\nconst CanvasContainer = Container({\n    name: 'CanvasContainer',\n    modules: [\n        { class: Selection },\n        { class: Canvas }\n    ],\n    mediatorOpts: {\n        conceal: [\n            /selection:.*?/\n        ]\n    },\n    handlers: {\n        events: {\n            'canvas:created' : 'handleCanvasCreated'\n        }\n    },\n    methods: {\n        init () {\n        },\n\n        handleCanvasCreated () {\n            const { mediator } = this;\n            const canvasWin = mediator.get('canvas:window');\n            const canvasDoc = mediator.get('canvas:document');\n            const canvasBody = mediator.get('canvas:body');\n\n            mediator.exec('selection:set:contextWindow', canvasWin);\n            mediator.exec('selection:set:contextDocument', canvasDoc);\n            mediator.exec('selection:set:el', canvasBody);\n        }\n    }\n});\n\nexport default CanvasContainer;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/containers/CanvasContainer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 56,
    "kind": "variable",
    "name": "CanvasContainer",
    "memberof": "scripts/containers/CanvasContainer.js",
    "static": true,
    "longname": "scripts/containers/CanvasContainer.js~CanvasContainer",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/containers/CanvasContainer.js",
    "importStyle": "CanvasContainer",
    "description": "",
    "lineNumber": 10,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 57,
    "kind": "file",
    "name": "scripts/containers/FormatterContainer.js",
    "content": "// jshint strict: false\n\nimport Container from '../core/Container';\n\nimport BaseFormatter from '../modules/BaseFormatter';\nimport BlockFormatter from '../modules/BlockFormatter';\nimport TextFormatter from '../modules/TextFormatter';\nimport ListFormatter from '../modules/ListFormatter';\nimport LinkFormatter from '../modules/LinkFormatter';\nimport Paste from '../modules/Paste';\n\n/**\n* @access protected\n*/\nconst FormatterContainer = Container({\n    name: 'FormatterContainer',\n    modules: [\n        {\n            class: BaseFormatter\n        },\n        {\n            class: BlockFormatter\n        },\n        {\n            class: TextFormatter\n        },\n        {\n            class: ListFormatter\n        },\n        {\n            class: LinkFormatter\n        },\n        {\n            class: Paste\n        }\n    ]\n});\n\nexport default FormatterContainer;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/containers/FormatterContainer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 58,
    "kind": "variable",
    "name": "FormatterContainer",
    "memberof": "scripts/containers/FormatterContainer.js",
    "static": true,
    "longname": "scripts/containers/FormatterContainer.js~FormatterContainer",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/containers/FormatterContainer.js",
    "importStyle": "FormatterContainer",
    "description": "",
    "lineNumber": 15,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "file",
    "name": "scripts/containers/UIContainer.js",
    "content": "// jshint strict: false\n\nimport Container from '../core/Container';\n\nimport Toolbar from '../modules/Toolbar';\nimport Flyout from '../modules/Flyout';\nimport Mouse from '../modules/Mouse';\n\n/**\n* @access protected\n*/\nconst UIContainer = Container({\n    name: 'UIContainer',\n    modules: [\n        {\n            class: Flyout\n        },\n        {\n            class: Toolbar,\n            opts: {\n                dom: {\n                    el: document.body\n                }\n            }\n        },\n        {\n            class: Mouse\n        }\n    ]\n});\n\nexport default UIContainer;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/containers/UIContainer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 60,
    "kind": "variable",
    "name": "UIContainer",
    "memberof": "scripts/containers/UIContainer.js",
    "static": true,
    "longname": "scripts/containers/UIContainer.js~UIContainer",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/containers/UIContainer.js",
    "importStyle": "UIContainer",
    "description": "",
    "lineNumber": 12,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "file",
    "name": "scripts/core/Container.js",
    "content": "// jshint strict: false\n\nimport Mediator from './Mediator';\nimport Context from './Context';\nimport func from '../utils/func';\n\n/**\n* @access protected\n*/\nconst Container = function Container(containerObj) {\n    const {\n        name: containerName,\n        handlers: containerHandlers,\n        methods: containerMethods,\n        modules: containerModules,\n        containers: containerChildContainers,\n        mediatorOpts\n    } = containerObj;\n\n    if (!containerName) {\n        throw new Error('No name given for container');\n    }\n\n    const containerUtils = {\n        createContext (...contexts) {\n            return new Context(...contexts);\n        },\n\n        bindMethods (methods, context) {\n            methods = methods || {};\n            return func.bindObj(methods, context);\n        },\n\n        initModules (modules=[], opts={}) {\n            modules.forEach((module) => {\n                const moduleOpts = Object.assign({}, opts, (module.opts || {}));\n                module.instance = new module.class(moduleOpts);\n            });\n        },\n\n        initChildContainers (childContainers=[], opts={}) {\n            childContainers.forEach((containerObj) => {\n                const containerOpts = Object.assign({}, opts, (containerObj.opts || {}));\n                containerObj.instance = new containerObj.class(containerOpts);\n            });\n        },\n\n        registerHandlers (mediator, handlers, context) {\n            Object.keys(handlers).forEach((handlerKey) => {\n                const handlerMap = handlers[handlerKey];\n                let handlerMethods = containerUtils.getHandlerMethods(handlerMap, context);\n\n                switch (handlerKey) {\n                case 'requests':\n                    mediator.registerRequestHandlers(handlerMethods);\n                    break;\n                case 'commands':\n                    mediator.registerCommandHandlers(handlerMethods);\n                    break;\n                case 'events':\n                    mediator.registerEventHandlers(handlerMethods);\n                    break;\n                }\n            });\n        },\n\n        getHandlerMethods (handlerMap, context) {\n            let routedHandlers = {};\n\n            Object.keys(handlerMap).forEach((commandStr) => {\n                const methodKey = handlerMap[commandStr];\n                const handlerMethod = context[methodKey];\n                routedHandlers[commandStr] = handlerMethod;\n            });\n\n            return routedHandlers;\n        }\n    };\n\n    const containerProto = {\n        containerConstructor: function (opts={}) {\n            const context = containerUtils.createContext();\n            const boundMethods = containerUtils.bindMethods(containerMethods, context);\n            context.extendWith(boundMethods);\n            const mediator = new Mediator(Object.assign({ parent: opts.mediator }, mediatorOpts));\n            context.extendWith({ mediator });\n\n            if (containerHandlers) {\n                containerUtils.registerHandlers(mediator, containerHandlers, context);\n            }\n\n            if (boundMethods.setup) {\n                boundMethods.setup();\n            }\n\n            containerUtils.initModules(containerModules, {\n                dom: opts.dom,\n                mediator\n            });\n\n            containerUtils.initChildContainers(containerChildContainers, {\n                dom: opts.dom,\n                mediator\n            });\n\n            if (boundMethods.init) {\n                boundMethods.init();\n            }\n\n            return {\n                setMediatorParent (parentMediator) {\n                    mediator.setParent(parentMediator);\n                }\n            };\n        }\n    };\n\n    return containerProto.containerConstructor;\n};\n\nexport default Container;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/core/Container.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 62,
    "kind": "function",
    "name": "Container",
    "memberof": "scripts/core/Container.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "scripts/core/Container.js~Container",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/core/Container.js",
    "importStyle": "Container",
    "description": "",
    "lineNumber": 10,
    "params": [
      {
        "name": "containerObj",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "file",
    "name": "scripts/core/Context.js",
    "content": "// jshint strict: false\n\n/**\n* @access protected\n*/\nconst Context = function (...contexts) {\n    this.mixin(...contexts);\n};\n\nObject.assign(Context.prototype, {\n    mixin (...contexts) {\n        contexts.forEach((context) => {\n            Object.assign(this, context);\n        });\n    },\n\n    extendWith (mixinContext, opts={}) {\n        if (opts.keys) {\n            opts.keys.forEach((key) => {\n                this[key] = mixinContext[key];\n            });\n        } else {\n            this.mixin(mixinContext);\n        }\n    }\n});\n\nexport default Context;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/core/Context.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 64,
    "kind": "function",
    "name": "Context",
    "memberof": "scripts/core/Context.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "scripts/core/Context.js~Context",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/core/Context.js",
    "importStyle": "Context",
    "description": "",
    "lineNumber": 6,
    "params": [
      {
        "name": "contexts",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 65,
    "kind": "file",
    "name": "scripts/core/Mediator.js",
    "content": "// jshint strict: false\nimport guid from '../utils/guid';\n\n/**\n* @access protected\n*/\nconst Mediator = function (opts={}) {\n    const internal = {\n        parent: opts.parent,\n        children: [],\n        id: guid(),\n        conceal: opts.conceal || []\n    };\n\n    const requests = {\n        handlers: {},\n\n        new (requestKey, requestHandler) {\n            if (requests.handlers[requestKey]) {\n                throw new Error(`Only one requestHandler per requestKey: ${requestKey}`);\n            }\n\n            requests.handlers[requestKey] = requestHandler;\n        },\n\n        getHandler (requestKey) {\n            return requests.handlers[requestKey];\n        },\n\n        canHandle (requestKey) {\n            return !!requests.getHandler(requestKey);\n        },\n\n        request (requestKey, options) {\n            const requestHandler = requests.getHandler(requestKey);\n\n            if (requestHandler) {\n                return requestHandler(options);\n            }\n        }\n    };\n\n    const commands = {\n        handlers: {},\n\n        new (commandKey, commandHandler) {\n            if (commands.handlers[commandKey]) {\n                throw new Error(`Only one commandHandler per commandKey: ${commandKey}`);\n            }\n\n            commands.handlers[commandKey] = commandHandler;\n        },\n\n        getHandler (commandKey) {\n            return commands.handlers[commandKey];\n        },\n\n        canHandle (commandKey) {\n            return !!commands.getHandler(commandKey);\n        },\n\n        exec (commandKey, options) {\n            const commandHandler = commands.getHandler(commandKey);\n            if (commandHandler) {\n                commandHandler(options);\n            }\n        }\n    };\n\n    const events = {\n        handlers: {},\n\n        new (eventKey, eventHandler) {\n            events.handlers[eventKey] = events.handlers[eventKey] || [];\n            events.handlers[eventKey].push(eventHandler);\n        },\n\n        getHandlers (eventKey) {\n            return events.handlers[eventKey] || [];\n        },\n\n        canHandle (eventKey) {\n            return !!events.getHandlers(eventKey);\n        },\n\n        emit (eventKey, options) {\n            const eventHandlers = events.getHandlers(eventKey);\n            if (eventHandlers.length) {\n                eventHandlers.forEach((eventHandler) => eventHandler(options));\n            }\n        }\n    };\n\n    const registers = {\n        registerHandler (type, typeKey, typeHandler) {\n            switch (type) {\n            case 'request':\n                requests.new(typeKey, typeHandler);\n                break;\n            case 'command':\n                commands.new(typeKey, typeHandler);\n                break;\n            case 'event':\n                events.new(typeKey, typeHandler);\n                break;\n            }\n        },\n\n        registerRequestHandlers (requestHandlers={}) {\n            Object.keys(requestHandlers).forEach((requestKey) => {\n                let requestHandler = requestHandlers[requestKey];\n                registers.registerHandler('request', requestKey, requestHandler);\n            });\n        },\n\n        registerCommandHandlers (commandHandlers={}) {\n            Object.keys(commandHandlers).forEach((commandKey) => {\n                let commandHandler = commandHandlers[commandKey];\n                registers.registerHandler('command', commandKey, commandHandler);\n            });\n        },\n\n        registerEventHandlers (eventHandlers={}) {\n            Object.keys(eventHandlers).forEach((eventKey) => {\n                let eventHandler = eventHandlers[eventKey];\n                registers.registerHandler('event', eventKey, eventHandler);\n            });\n        }\n    };\n\n    const fn = {\n        init () {\n            if (internal.parent) {\n                internal.parent.registerChild(api);\n            }\n        },\n\n        shouldConceal (msgKey) {\n            let shouldConceal = false;\n\n            internal.conceal.forEach((concealPattern) => {\n                shouldConceal = shouldConceal || concealPattern.test(msgKey);\n            });\n\n            return shouldConceal;\n        },\n\n        delegate (type, msgKey, args={}, opts={}) {\n            const { _state } = opts;\n\n            if (!_state.hasAttempted(internal.id)) {\n                fn.handle(type, msgKey, args, opts);\n            }\n\n            if (!_state.hasBeenHandled) {\n                internal.children.forEach((childMediator) => {\n                    if (\n                        !_state.hasBeenHandled &&\n                        !_state.hasAttempted(childMediator.getId())\n                    ) {\n                        childMediator.handle(type, msgKey, args, opts);\n                    }\n                });\n            }\n\n            if (!_state.hasBeenHandled) {\n                if (\n                    internal.parent &&\n                    !_state.hasAttempted(internal.parent.getId()) &&\n                    !fn.shouldConceal(msgKey)\n                ) {\n                    internal.parent.delegate(type, msgKey, args, opts);\n                }\n            }\n\n            return _state.response;\n        },\n\n        canHandle (type, msgKey) {\n            switch (type) {\n            case 'request':\n                return requests.canHandle(msgKey);\n            case 'command':\n                return commands.canHandle(msgKey);\n            case 'event':\n                return events.canHandle(msgKey);\n            }\n        },\n\n        handle (type, msgKey, args={}, opts={}) {\n            opts._state = opts._state || fn.newStateObj();\n\n            const canHandle = fn.canHandle(type, msgKey);\n            const { _state } = opts;\n\n            if (_state.hasAttempted(internal.id)) {\n                return _state.response;\n            }\n\n            opts._state.logAttempt(internal.id);\n            if (canHandle) {\n                switch (type) {\n                case 'request':\n                    _state.response = requests.request(msgKey, args);\n                    _state.hasBeenHandled = true;\n                    break;\n                case 'command':\n                    commands.exec(msgKey, args);\n                    _state.hasBeenHandled = true;\n                    break;\n                case 'event':\n                    events.emit(msgKey, args);\n                    fn.delegate(type, msgKey, args, opts);\n                    break;\n                }\n\n                return _state.response;\n            } else {\n                return fn.delegate(type, msgKey, args, opts);\n            }\n        },\n\n        newStateObj () {\n            const stateObj = {\n                attempts: [],\n                hasBeenHandled: false,\n                response: null,\n                logAttempt (mediatorId) {\n                    this.attempts.push(mediatorId);\n                },\n                hasAttempted (mediatorId) {\n                    return this.attempts.indexOf(mediatorId) > -1;\n                }\n            };\n\n            return stateObj;\n        },\n\n        request (requestKey, opts={}) {\n            return fn.handle('request', requestKey, opts);\n        },\n\n        exec (commandKey, opts={}) {\n            fn.handle('command', commandKey, opts);\n        },\n\n        emit (eventKey, opts={}) {\n            fn.handle('event', eventKey, opts);\n        },\n\n        hasAttemptedToHandle (opts) {\n            return opts.attemptedDelegates.indexOf(internal.id) > -1;\n        },\n\n        registerChild (childApi) {\n            childApi.childIndex = internal.children.length;\n            internal.children.push(childApi);\n        },\n\n        deregisterChild (childApi) {\n            internal.children.slice(childApi.childIndex, 1);\n        },\n\n        setParent (parentApi) {\n            if (internal.parent) {\n                internal.parent.deregisterChild(api);\n            }\n\n            internal.parent = parentApi;\n            internal.parent.registerChild(api);\n        },\n\n        getId () {\n            return internal.id;\n        }\n    };\n\n    const api = {\n        getId: fn.getId,\n        registerRequestHandlers: registers.registerRequestHandlers,\n        registerCommandHandlers: registers.registerCommandHandlers,\n        registerEventHandlers: registers.registerEventHandlers,\n        registerHandler: registers.registerHandler,\n        request: fn.request,\n        exec: fn.exec,\n        emit: fn.emit,\n        get: fn.request,\n        canHandle: fn.canHandle,\n        handle: fn.handle,\n        registerChild: fn.registerChild,\n        hasAttemptedToHandle: fn.hasAttemptedToHandle,\n        deregisterChild: fn.deregisterChild,\n        setParent: fn.setParent,\n        delegate: fn.delegate,\n        getHandlerKeys: function () {\n            let handlers = [];\n\n            handlers.concat(Object.keys(requests.handlers));\n            handlers.concat(Object.keys(commands.handlers));\n            handlers.concat(Object.keys(events.handlers));\n\n            return handlers;\n        }\n    };\n\n    fn.init();\n\n    return api;\n};\n\nexport default Mediator;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/core/Mediator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 66,
    "kind": "function",
    "name": "Mediator",
    "memberof": "scripts/core/Mediator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "scripts/core/Mediator.js~Mediator",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/core/Mediator.js",
    "importStyle": "Mediator",
    "description": "",
    "lineNumber": 7,
    "params": [
      {
        "name": "opts",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "file",
    "name": "scripts/core/Module.js",
    "content": "// jshint strict: false\n\nimport Context from './Context';\nimport func from '../utils/func';\nimport DOM from '../utils/DOM';\n\n/**\n* @access protected\n*/\nconst Module = function (moduleObj) {\n    const {\n        name: moduleName,\n        props: moduleProps,\n        handlers: moduleHandlers,\n        dom: moduleDom,\n        methods: moduleMethods,\n        requiredProps: moduleRequiredProps\n    } = moduleObj;\n\n    if (!moduleName) {\n        throw new Error('No name given for module', moduleObj);\n    }\n\n    const moduleUtils = {\n        createContext (...contexts) {\n            return new Context(...contexts);\n        },\n\n        bindMethods (methods, context) {\n            methods = methods || {};\n            return func.bindObj(methods, context);\n        },\n\n        wrapRenderMethod (renderMethod, opts) {\n            const wrappedRenderMethod = function (...args) {\n                let { context } = opts;\n                let mergedDom;\n\n                mergedDom = moduleUtils.mergeDom(moduleDom, opts.dom);\n                mergedDom.el = renderMethod(...args);\n\n                moduleUtils.getDom(mergedDom);\n                context.extendWith({ dom: mergedDom });\n\n                if (moduleHandlers.domEvents) {\n                    moduleUtils.registerDomHandlers(moduleHandlers.domEvents, context);\n                }\n            };\n            return wrappedRenderMethod;\n        },\n\n        registerHandlers (mediator, handlers, context) {\n            Object.keys(handlers).forEach((handlerKey) => {\n                const handlerMap = handlers[handlerKey];\n                let handlerMethods = moduleUtils.getHandlerMethods(handlerMap, context);\n                switch (handlerKey) {\n                case 'requests':\n                    mediator.registerRequestHandlers(handlerMethods);\n                    break;\n                case 'commands':\n                    mediator.registerCommandHandlers(handlerMethods);\n                    break;\n                case 'events':\n                    mediator.registerEventHandlers(handlerMethods);\n                    break;\n                }\n            });\n        },\n\n        registerDomHandlers (domHandlersMap, context) {\n            let handlerMethods = moduleUtils.getHandlerMethods(domHandlersMap, context);\n            moduleUtils.bindDomEvents(handlerMethods, context);\n        },\n\n        getHandlerMethods (handlerMap, context) {\n            let routedHandlers = {};\n\n            Object.keys(handlerMap).forEach((commandStr) => {\n                const methodKey = handlerMap[commandStr];\n                const handlerMethod = context[methodKey];\n                routedHandlers[commandStr] = handlerMethod;\n            });\n\n            return routedHandlers;\n        },\n\n        mergeDom (defaultDom, dom={}) {\n            let mergedDom = {};\n            Object.keys(defaultDom).forEach((domKey) => {\n                mergedDom[domKey] = defaultDom[domKey];\n            });\n\n            Object.keys(dom).forEach((domKey) => {\n                mergedDom[domKey] = dom[domKey];\n                mergedDom[domKey].selector = dom[domKey];\n            });\n\n            return mergedDom;\n        },\n\n        getDom (dom) {\n            const rootEl = dom.el || document.body;\n            Object.keys(dom).forEach((domKey) => {\n                let selector, domEl;\n\n                selector = dom[domKey];\n                if (selector === null) {\n                    return;\n                } else if (typeof selector === 'object') {\n                    selector = selector.selector || selector;\n                }\n\n                domEl = DOM.get(selector, rootEl);\n                domEl.selector = selector;\n\n                dom[domKey] = domEl;\n            });\n        },\n\n        bindDomEvents (handlers, context) {\n            const { dom } = context;\n\n            Object.keys(handlers).forEach((eventElKey) => {\n                const [eventKey, elemKey] = eventElKey.split(' @');\n                const elem = elemKey ? dom[elemKey][0] : dom.el[0];\n                const eventHandler = handlers[eventElKey];\n\n                elem.addEventListener(eventKey, eventHandler);\n            });\n        },\n\n        mergeProps (defaultProps, props={}) {\n            let mergedProps = {};\n\n            Object.keys(defaultProps).forEach((propKey) => {\n                const propValue = props[propKey] || defaultProps[propKey];\n                mergedProps[propKey] = propValue;\n            });\n\n            return mergedProps;\n        },\n\n        validateProps (props, requiredProps) {\n            Object.keys(props).forEach((propKey) => {\n                if (requiredProps.indexOf(propKey) > -1 && !props[propKey]) {\n                    throw new Error(`${moduleName} requires prop: ${propKey}`);\n                }\n            });\n        }\n    };\n\n    const moduleProto = {\n        moduleConstructor: function (opts) {\n            moduleProto.prepModule(opts);\n            moduleProto.buildModule(opts);\n            moduleProto.setupModule(opts);\n            moduleProto.renderModule(opts);\n            moduleProto.initModule(opts);\n        },\n\n        prepModule (opts) {\n            const context = moduleUtils.createContext();\n\n            if (moduleProps) {\n                const mergedProps = moduleUtils.mergeProps(moduleProps, opts.props);\n                context.extendWith({ props: mergedProps});\n\n                if (moduleRequiredProps) {\n                    moduleUtils.validateProps(mergedProps, moduleRequiredProps);\n                }\n            }\n\n            opts.context = context;\n        },\n\n        buildModule (opts) {\n            const { context } = opts;\n            const boundMethods = moduleUtils.bindMethods(moduleMethods, context);\n\n            if (boundMethods.render) {\n                boundMethods.render = moduleUtils.wrapRenderMethod(boundMethods.render, opts);\n            }\n\n            context.extendWith(boundMethods);\n            context.extendWith({mediator: opts.mediator});\n        },\n\n        setupModule (opts) {\n            const { context } = opts;\n            if (context.setup) {\n                context.setup();\n            }\n\n            if (moduleHandlers) {\n                moduleUtils.registerHandlers(opts.mediator, moduleHandlers, context);\n            }\n        },\n\n        renderModule (opts) {\n            let { context } = opts;\n            let mergedDom;\n\n            if (context.render) {\n                return;\n            }\n\n            if (moduleDom) {\n                mergedDom = moduleUtils.mergeDom(moduleDom, opts.dom);\n                moduleUtils.getDom(mergedDom);\n                context.extendWith({dom: mergedDom});\n            }\n\n            if (moduleHandlers.domEvents) {\n                moduleUtils.registerDomHandlers(moduleHandlers.domEvents, context);\n            }\n        },\n\n        initModule (opts) {\n            const { context } = opts;\n\n            if (context.init) {\n                context.init();\n            }\n        },\n\n        destroyModule () {\n\n        }\n    };\n\n    return moduleProto.moduleConstructor;\n};\n\nexport default Module;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/core/Module.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 68,
    "kind": "function",
    "name": "Module",
    "memberof": "scripts/core/Module.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "scripts/core/Module.js~Module",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/core/Module.js",
    "importStyle": "Module",
    "description": "",
    "lineNumber": 10,
    "params": [
      {
        "name": "moduleObj",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "file",
    "name": "scripts/index.js",
    "content": "// jshint strict: false\n/* eslint-disable no-alert, no-console */\n\nimport './polyfills';\nimport AppContainer from './containers/AppContainer';\n\n/**\n * Tyester() - Public interface to instatiate a Typester instance bound to a\n * dom element\n *\n * @access public\n * @param  {object} opts={} instance options\n * @param  {element} opts.dom.el The dom element to be the canvas for Typester\n * @return {appContainer} AppContainer instance\n *\n * @example\n * new Typester({\n *   dom: {\n *     el: domElement\n *   }\n * });\n */\nconst Typester = function (opts={}) {\n    return new AppContainer({ dom: {el: opts.el }});\n};\n\nexport default Typester;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 70,
    "kind": "function",
    "name": "Typester",
    "memberof": "scripts/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "scripts/index.js~Typester",
    "access": "public",
    "export": true,
    "importPath": "typester/scripts/index.js",
    "importStyle": "Typester",
    "description": "Tyester() - Public interface to instatiate a Typester instance bound to a\ndom element",
    "examples": [
      "new Typester({\n  dom: {\n    el: domElement\n  }\n});"
    ],
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "opts",
        "description": "instance options"
      },
      {
        "nullable": null,
        "types": [
          "element"
        ],
        "spread": false,
        "optional": false,
        "name": "opts.dom.el",
        "description": "The dom element to be the canvas for Typester"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "appContainer"
      ],
      "spread": false,
      "description": "AppContainer instance"
    }
  },
  {
    "__docId__": 71,
    "kind": "file",
    "name": "scripts/modules/BaseFormatter.js",
    "content": "// jshint strict: false\n\nimport Module from '../core/Module';\nimport commands from '../utils/commands';\nimport DOM from '../utils/DOM';\nimport zeroWidthSpace from '../utils/zeroWidthSpace';\n\nimport toolbarConfig from '../config/toolbar';\n\nlet validTags = toolbarConfig.getValidTags();\nlet blockTags = toolbarConfig.getBlockTags();\nlet listTags  = toolbarConfig.getListTags();\n\n/**\n* @access protected\n*/\nconst BaseFormatter = Module({\n    name: 'BaseFormatter',\n    props: {},\n    handlers: {\n        requests: {},\n        commands: {\n            'format:export:to:canvas': 'exportToCanvas',\n            'format:import:from:canvas': 'importFromCanvas',\n            'format:default': 'formatDefault',\n            'format:clean': 'formatClean'\n        },\n        events: {\n            'contenteditable:newline': 'handleNewLine'\n        }\n    },\n    methods: {\n        init () {},\n\n        exportToCanvas () {\n            const { mediator } = this;\n            const rootElement = mediator.get('selection:rootelement');\n            const canvasBody = mediator.get('canvas:body');\n            this.injectHooks(rootElement);\n\n            const rangeCoordinates = mediator.get('selection:range:coordinates');\n            const clonedNodes = this.cloneNodes(rootElement);\n            mediator.exec('canvas:content', clonedNodes);\n            mediator.exec('canvas:select:by:coordinates', rangeCoordinates);\n\n            this.removeZeroWidthSpaces(canvasBody);\n        },\n\n        cloneNodes (rootElement) {\n            let clonedNodes = [];\n            rootElement.childNodes.forEach((node) => {\n                clonedNodes.push(node.cloneNode(true));\n            });\n            return clonedNodes;\n        },\n\n        injectHooks (rootElement) {\n            while (!/\\w+/.test(rootElement.firstChild.textContent)) {\n                DOM.removeNode(rootElement.firstChild);\n            }\n\n            while(!/\\w+/.test(rootElement.lastChild.textContent)) {\n                DOM.removeNode(rootElement.lastChild);\n            }\n\n            DOM.insertBefore(zeroWidthSpace.get(), rootElement.firstChild);\n            DOM.insertAfter(zeroWidthSpace.get(), rootElement.lastChild);\n        },\n\n        importFromCanvas (opts={}) {\n            const { mediator } = this;\n            const canvasBody = mediator.get('canvas:body');\n\n            mediator.exec('canvas:cache:selection');\n            mediator.exec('format:clean', canvasBody);\n            if (opts.importFilter) {\n                opts.importFilter(canvasBody);\n            }\n            mediator.exec('canvas:select:cachedSelection');\n\n            const canvasSelectionCoordinates = mediator.get('canvas:selection:coordinates');\n            mediator.exec('selection:select:all');\n            mediator.exec('contenteditable:inserthtml', canvasBody.innerHTML);\n            mediator.exec('selection:select:coordinates', canvasSelectionCoordinates);\n\n            mediator.emit('import:from:canvas:complete');\n        },\n\n        formatDefault () {\n            const { mediator } = this;\n            const rootElem = mediator.get('selection:rootelement');\n            commands.defaultBlockFormat();\n            this.removeStyledSpans(rootElem);\n        },\n\n        formatEmptyNewLine () {\n            const { mediator } = this;\n            const anchorNode = mediator.get('selection:anchornode');\n            const canDefaultNewline = !(anchorNode.innerText && anchorNode.innerText.trim().length) && !DOM.isIn(anchorNode, toolbarConfig.preventNewlineDefault);\n            const anchorIsContentEditable = anchorNode.hasAttribute && anchorNode.hasAttribute('contenteditable');\n\n            if (canDefaultNewline || anchorIsContentEditable) {\n                this.formatDefault();\n            }\n        },\n\n        formateBlockquoteNewLine () {\n            const { mediator } = this;\n\n            commands.exec('outdent');\n            this.formatDefault();\n\n            const currentRangeClone = mediator.get('selection:range').cloneRange();\n            const { startContainer } = currentRangeClone;\n\n            if (startContainer.previousSibling && startContainer.previousSibling.nodeName === 'BLOCKQUOTE') {\n                const brEls = startContainer.previousSibling.querySelectorAll('br');\n                const divEls = startContainer.previousSibling.querySelectorAll('div');\n\n                for (let i = 0; i < brEls.length; i++) {\n                    DOM.removeNode(brEls[i]);\n                }\n\n                for (let i = 0; i < divEls.length; i++) {\n                    DOM.unwrap(divEls[i]);\n                }\n\n                mediator.exec('selection:update:range', currentRangeClone);\n            }\n\n        },\n\n        handleNewLine () {\n            const { mediator } = this;\n            const { startContainer } = mediator.get('selection:range');\n            const containerIsEmpty = !/\\w+/.test(startContainer.textContent);\n            const containerIsBlockquote = DOM.isIn(startContainer, 'BLOCKQUOTE');\n            const isContentEditable = startContainer.nodeType === Node.ELEMENT_NODE && startContainer.hasAttribute('contenteditable');\n\n            if (containerIsBlockquote) {\n                this.formateBlockquoteNewLine();\n            } else if (containerIsEmpty || isContentEditable) {\n                this.formatEmptyNewLine();\n            }\n        },\n\n        formatClean (rootElem) {\n            this.unwrapInvalidElements(rootElem);\n            this.defaultOrphanedTextNodes(rootElem);\n            this.removeBrNodes(rootElem);\n            this.ensureRootElems(rootElem);\n            this.removeStyleAttributes(rootElem);\n            this.removeEmptyNodes(rootElem, { recursive: true });\n\n            // -----\n\n            // this.removeBrNodes(rootElem);\n            // // this.removeEmptyNodes(rootElem);\n            // this.removeFontTags(rootElem);\n            // this.removeStyledSpans(rootElem);\n            // this.clearEntities(rootElem);\n            // this.removeZeroWidthSpaces(rootElem);\n            // this.defaultOrphanedTextNodes(rootElem);\n            // this.removeEmptyNodes(rootElem, { recursive: true });\n        },\n\n        removeStyleAttributes (rootElem) {\n            const styleAttributeNodes = rootElem.querySelectorAll('[style]');\n            styleAttributeNodes.forEach((styleAttributeNode) => {\n                styleAttributeNode.removeAttribute('style');\n            });\n        },\n\n        removeBrNodes (rootElem) {\n            const brNodes = rootElem.querySelectorAll('br');\n            let brNodesToProcess = [];\n            let brNodesToRemove = [];\n\n            brNodes.forEach((brNode) => {\n                const skipNode = brNode.skipNode;\n\n                if (skipNode) {\n                    return;\n                }\n\n                const isLastChild = brNode === brNode.parentNode.lastChild;\n                const isDoubleBreak = brNode.nextSibling && brNode.nextSibling.nodeName === 'BR';\n                const isInBlock = DOM.isIn(brNode, blockTags, rootElem);\n\n                if (isLastChild) {\n                    brNodesToRemove.push(isLastChild);\n                    return;\n                }\n\n                if (isDoubleBreak && isInBlock) {\n                    brNodesToProcess.push([\n                        brNode,\n                        brNode.nextSibling\n                    ]);\n                    brNode.nextSibling.skipNode = true;\n                    return;\n                }\n            });\n\n            brNodesToProcess.forEach((brNodePair) => {\n                const [firstBrNode, secondBrNode] = brNodePair;\n                const closestBlock = DOM.getClosestInArray(firstBrNode, blockTags, rootElem);\n                const newParagraph = document.createElement('p');\n                let previousSibling;\n\n                while ((previousSibling = firstBrNode.previousSibling)) {\n                    if (newParagraph.firstChild) {\n                        DOM.insertBefore(previousSibling, newParagraph.firstChild);\n                    } else {\n                        newParagraph.appendChild(previousSibling);\n                    }\n\n                    DOM.insertBefore(newParagraph, closestBlock);\n                }\n\n                DOM.removeNode(firstBrNode);\n                DOM.removeNode(secondBrNode);\n            });\n\n            brNodesToRemove.forEach((brNode) => {\n                DOM.removeNode(brNode);\n            });\n        },\n\n        unwrapInvalidElements (rootElem) {\n            const rootDoc = rootElem.ownerDocument;\n            const walker = rootDoc.createTreeWalker(\n                rootElem,\n                NodeFilter.SHOW_ELEMENT,\n                null,\n                false\n            );\n\n            let invalidElements = [];\n            while (walker.nextNode()) {\n                let { currentNode } = walker;\n                let isInvalid = validTags.indexOf(currentNode.nodeName) < 0;\n                let isBrNode = currentNode.nodeName === 'BR'; // BR nodes are handled elsewhere\n                let isTypesterElem = currentNode.className && /typester/.test(currentNode.className);\n\n                if (isInvalid && !isBrNode && !isTypesterElem) {\n                    invalidElements.unshift(currentNode);\n                }\n            }\n\n            invalidElements.forEach((invalidElement) => {\n                let unwrappedNodes = DOM.unwrap(invalidElement, { keepNode: true });\n                if (!DOM.isIn(invalidElement, validTags, rootElem) && unwrappedNodes.length) {\n                    let newParagraph = rootDoc.createElement('p');\n                    unwrappedNodes.forEach((unwrappedNode) => {\n                        newParagraph.appendChild(unwrappedNode);\n                    });\n                    DOM.insertBefore(newParagraph, invalidElement);\n                }\n                DOM.removeNode(invalidElement);\n            });\n        },\n\n        defaultOrphanedTextNodes (rootElem) {\n            const { childNodes } = rootElem;\n            for (let i = 0; i < childNodes.length; i++) {\n                let childNode = childNodes[i];\n                if (childNode.nodeType === Node.TEXT_NODE && /\\w+/.test(childNode.textContent)) {\n                    let newParagraph = document.createElement('p');\n                    DOM.insertBefore(newParagraph, childNode);\n                    newParagraph.appendChild(childNode);\n                    while (newParagraph.nextSibling && blockTags.concat(listTags).indexOf(newParagraph.nextSibling.nodeName) < 0) {\n                        newParagraph.appendChild(newParagraph.nextSibling);\n                    }\n                }\n            }\n        },\n\n        clearEntities (rootElem) {\n            const rootDoc = rootElem.ownerDocument;\n            const walker = rootDoc.createTreeWalker(\n                rootElem,\n                NodeFilter.SHOW_TEXT,\n                null,\n                false\n            );\n\n            let textNodes = [];\n            while(walker.nextNode()) {\n                textNodes.push(walker.currentNode);\n            }\n\n            textNodes.forEach((textNode) => {\n                if (/\\w+/.test(textNode.textContent)) {\n                    textNode.nodeValue = textNode.nodeValue.replace(/^\\u00a0/, '');\n                    textNode.nodeValue = textNode.nodeValue.replace(/\\u00a0$/, '');\n                }\n            });\n        },\n\n        ensureRootElems (rootElem) {\n            const rootNodeTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'OL', 'UL', 'BLOCKQUOTE', 'P'];\n            const nestableTags = [\n                {\n                    tags: ['OL', 'UL'],\n                    validParents: ['OL', 'UL', 'LI']\n                },\n                {\n                    tags: ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'],\n                    validParents: ['LI']\n                }\n            ];\n            const rootNodes = rootElem.querySelectorAll(rootNodeTags.join(', '));\n            const validNesting = function (node) {\n                let validNesting = false;\n                nestableTags.forEach((nestingDict) => {\n                    if (\n                        nestingDict.tags.indexOf(node.tagName) > -1 &&\n                        nestingDict.validParents.indexOf(node.parentNode.tagName) > -1\n                    ) {\n                        validNesting = true;\n                    }\n                });\n                return validNesting;\n            };\n\n            const moveNodeToRoot = function (node) {\n                if (\n                    node.parentNode === rootElem\n                ) {\n                    return;\n                }\n\n                if (validNesting(node)) {\n                    return;\n                }\n\n                let rootParentNode = node.parentNode;\n                if (node.tagName === 'P' && ['LI', 'BLOCKQUOTE'].indexOf(rootParentNode.tagName) > -1) {\n                    while (node.firstChild) {\n                        DOM.insertBefore(node.firstChild, node);\n                    }\n                    DOM.removeNode(node);\n                    return;\n                }\n\n                while (\n                    rootParentNode.parentNode !== rootElem\n                ) {\n                    rootParentNode = rootParentNode.parentNode;\n                }\n\n                DOM.insertBefore(node, rootParentNode);\n            };\n\n            rootNodes.forEach(moveNodeToRoot);\n        },\n\n        removeZeroWidthSpaces (rootElem) {\n            rootElem.childNodes.forEach((childNode) => {\n                if (\n                    childNode.nodeType === Node.TEXT_NODE &&\n                    zeroWidthSpace.assert(childNode)\n                ) {\n                    DOM.removeNode(childNode);\n                }\n            });\n        },\n\n        removeEmptyNodes (rootElem, opts={}) {\n            if (rootElem.normalize) {\n                rootElem.normalize();\n            }\n\n            for (let i = rootElem.childNodes.length - 1; i >= 0; i--) {\n                let childNode = rootElem.childNodes[i];\n\n                if (childNode.nodeName === 'BR') {\n                    continue;\n                }\n\n                if (opts.recursive && childNode.childNodes.length) {\n                    this.removeEmptyNodes(childNode, { recursive: true, rootIsChild: true });\n                }\n\n                if (!/[\\w\\.,\\/#!$%\\^&\\*;:{}=\\-_`~()\\'\\\"]/.test(childNode.textContent)) {\n                    if (\n                        (!opts.rootIsChild && !zeroWidthSpace.assert(childNode) && i > 0) ||\n                        childNode.nodeType === Node.ELEMENT_NODE\n                    ) {\n                        DOM.removeNode(childNode);\n                    }\n                }\n            }\n        },\n\n        removeStyledSpans (rootElem) {\n            const styledSpans = rootElem.querySelectorAll('span[style]');\n            for (let i = styledSpans.length - 1; i >= 0; i--) {\n                let styledSpan = styledSpans[i];\n                while (styledSpan.firstChild) {\n                    DOM.insertBefore(styledSpan.firstChild, styledSpan);\n                }\n                DOM.removeNode(styledSpan);\n            }\n        },\n\n        removeFontNodes (rootElem) {\n            const fontTags = rootElem.querySelectorAll('font');\n            for (let i = fontTags.length - 1; i >= 0; i--) {\n                let fontTag = fontTags[i];\n                while (fontTag.firstChild) {\n                    DOM.insertBefore(fontTag.firstChild, fontTag);\n                }\n                DOM.removeNode(fontTag);\n            }\n        }\n    }\n});\n\nexport default BaseFormatter;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/BaseFormatter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 72,
    "kind": "variable",
    "name": "validTags",
    "memberof": "scripts/modules/BaseFormatter.js",
    "static": true,
    "longname": "scripts/modules/BaseFormatter.js~validTags",
    "access": "public",
    "export": false,
    "importPath": "typester/scripts/modules/BaseFormatter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 73,
    "kind": "variable",
    "name": "blockTags",
    "memberof": "scripts/modules/BaseFormatter.js",
    "static": true,
    "longname": "scripts/modules/BaseFormatter.js~blockTags",
    "access": "public",
    "export": false,
    "importPath": "typester/scripts/modules/BaseFormatter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 74,
    "kind": "variable",
    "name": "listTags",
    "memberof": "scripts/modules/BaseFormatter.js",
    "static": true,
    "longname": "scripts/modules/BaseFormatter.js~listTags",
    "access": "public",
    "export": false,
    "importPath": "typester/scripts/modules/BaseFormatter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 75,
    "kind": "variable",
    "name": "BaseFormatter",
    "memberof": "scripts/modules/BaseFormatter.js",
    "static": true,
    "longname": "scripts/modules/BaseFormatter.js~BaseFormatter",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/BaseFormatter.js",
    "importStyle": "BaseFormatter",
    "description": "",
    "lineNumber": 17,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "file",
    "name": "scripts/modules/BlockFormatter.js",
    "content": "// jshint strict: false\n\nimport Module from '../core/Module';\nimport commands from '../utils/commands';\nimport DOM from '../utils/DOM';\n\n/**\n* @access protected\n*/\nconst BlockFormatter = Module({\n    name: 'BlockFormatter',\n    props: {\n        selectionRootEl: null\n    },\n    handlers: {\n        commands: {\n            'format:block': 'formatBlock'\n        },\n        events: {}\n    },\n    methods: {\n        init () {},\n\n        formatBlock (opts) {\n            this.preProcess(opts);\n            this.process(opts);\n            this.commit(opts);\n        },\n\n        preProcess () {\n            const { mediator } = this;\n            mediator.exec('format:export:to:canvas');\n        },\n\n        process (opts) {\n            const { mediator } = this;\n            const canvasDoc = mediator.get('canvas:document');\n\n            if (opts.toggle) {\n                if (opts.style === 'BLOCKQUOTE') {\n                    commands.exec('outdent', null, canvasDoc);\n                }\n                commands.defaultBlockFormat(canvasDoc);\n            } else {\n                commands.formatBlock(opts.style, canvasDoc);\n            }\n        },\n\n        commit (opts) {\n            const { mediator, cleanupBlockquote } = this;\n            const importFilter = opts.style === 'BLOCKQUOTE' ? cleanupBlockquote : null;\n            mediator.exec('format:import:from:canvas', { importFilter });\n        },\n\n        cleanupBlockquote (rootElem) {\n            const blockquoteParagraphs = rootElem.querySelectorAll('BLOCKQUOTE P');\n            blockquoteParagraphs.forEach((paragraph) => {\n                DOM.unwrap(paragraph);\n            });\n        }\n    }\n});\n\nexport default BlockFormatter;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/BlockFormatter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 77,
    "kind": "variable",
    "name": "BlockFormatter",
    "memberof": "scripts/modules/BlockFormatter.js",
    "static": true,
    "longname": "scripts/modules/BlockFormatter.js~BlockFormatter",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/BlockFormatter.js",
    "importStyle": "BlockFormatter",
    "description": "",
    "lineNumber": 10,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "file",
    "name": "scripts/modules/Canvas.js",
    "content": "// jshint strict: false\n\nimport Module from '../core/Module';\nimport DOM from '../utils/DOM';\nimport zeroWidthSpace from '../utils/zeroWidthSpace';\n\nimport canvasStyles from '../../styles/canvas.scss';\n\n/**\n* @access protected\n*/\nconst Canvas = Module({\n    name: 'Canvas',\n    props: {\n        iframe: null,\n        relativeRange: null,\n        alreadyContainered: false,\n        cachedSelection: null\n    },\n    handlers: {\n        requests: {\n            'canvas:document' : 'getCanvasDocument',\n            'canvas:window' : 'getCanvasWindow',\n            'canvas:body' : 'getCanvasBody',\n            'canvas:formatted:block': 'getFormattedBlock',\n            'canvas:selection:coordinates' : 'getSelectionCoordinates',\n            'canvas:selection': 'getSelection',\n            'canvas:selection:in:or:contains': 'selectionInOrContains'\n        },\n        commands: {\n            'canvas:content' : 'setContent',\n            'canvas:insert:range' : 'insertRange',\n            'canvas:insert:node' : 'insertNode',\n            'canvas:select:all' : 'selectAll',\n            'canvas:select:by:coordinates' : 'selectByCoordinates',\n            'canvas:import:selection' : 'importSelection',\n            'canvas:export:prep': 'exportPrep',\n            'canvas:export:all': 'exportAll',\n            'canvas:cache:selection': 'cacheSelection',\n            'canvas:select:cachedSelection': 'selectCachedSelection',\n            'canvas:select:ensure:offsets': 'ensureSelectionOffsets'\n        },\n        events: {\n            'app:destroy' : 'destroy'\n        }\n    },\n    methods: {\n        init () {\n            this.appendStyles();\n            this.createIframe();\n        },\n\n        appendStyles () {\n            const { props } = this;\n            props.styles = DOM.addStyles(canvasStyles);\n        },\n\n        createIframe () {\n            const { mediator } = this;\n            const iframe = document.createElement('iframe');\n\n            iframe.classList.add('typester-canvas');\n            iframe.onload = () => {\n                this.setCanvasBodyEditable();\n                this.applyPolyfills();\n                mediator.emit('canvas:created');\n            };\n\n            this.props.iframe = iframe;\n            document.body.appendChild(iframe);\n        },\n\n        clearIframe () {\n            const canvasBody = this.getCanvasBody();\n            canvasBody.innerHTML = '';\n        },\n\n        reset () {\n            const { props } = this;\n            props.relativeRange = null;\n            props.alreadyContainered = false;\n            props.cachedSelection = null;\n            this.clearIframe();\n        },\n\n        cacheSelection () {\n            const { props, mediator } = this;\n\n            mediator.exec('selection:ensure:text:only');\n\n            const {\n                anchorNode,\n                anchorOffset,\n                focusNode,\n                focusOffset\n            } = mediator.get('selection:current');\n\n            props.cachedSelection = {\n                anchorNode,\n                anchorOffset,\n                focusNode,\n                focusOffset\n            };\n        },\n\n        selectCachedSelection () {\n            const { props, mediator } = this;\n\n            const {\n                anchorNode,\n                anchorOffset,\n                focusNode,\n                focusOffset\n            } = props.cachedSelection;\n\n            const canvasDoc = this.getCanvasDocument();\n            const newRange = canvasDoc.createRange();\n\n            newRange.setStart(anchorNode, anchorOffset);\n            newRange.setEnd(focusNode, focusOffset);\n\n            mediator.exec('selection:update:range', newRange);\n        },\n\n        ensureSelectionOffsets () {\n            const { props, mediator } = this;\n\n            if (!props.cachedSelection) {\n                return;\n            }\n\n            const {\n                anchorNode: currentAnchorNode,\n                anchorOffset: currentAnchorOffset,\n                focusNode: currentFocusNode,\n                focusOffset: currentFocusOffset\n            } = mediator.get('selection:current');\n\n            const {\n                anchorOffset: cachedAnchorOffset,\n                focusOffset: cachedFocusOffset\n            } = props.cachedSelection;\n\n            const anchorOffsetMismatch = currentAnchorOffset !== cachedAnchorOffset;\n            const focusOffsetMismatch = currentFocusOffset !== cachedFocusOffset;\n\n            if (anchorOffsetMismatch || focusOffsetMismatch) {\n                const canvasDoc = this.getCanvasDocument();\n                const newRange = canvasDoc.createRange();\n\n                newRange.setStart(currentAnchorNode, cachedAnchorOffset);\n                newRange.setEnd(currentFocusNode, cachedFocusOffset);\n\n                mediator.exec('selection:update:range', newRange);\n            }\n        },\n\n        setCanvasBodyEditable () {\n            const { props } = this;\n            const canvasBody = props.iframe.contentDocument.body;\n            canvasBody.contentEditable = true;\n        },\n\n        applyPolyfills () {\n            const canvasWindow = this.getCanvasWindow();\n            if (canvasWindow.NodeList && !canvasWindow.NodeList.prototype.forEach) {\n                canvasWindow.NodeList.prototype.forEach = function (callback, thisArg) {\n                    thisArg = thisArg || canvasWindow;\n                    for (var i = 0; i < this.length; i++) {\n                        callback.call(thisArg, this[i], i, this);\n                    }\n                };\n            }\n        },\n\n        // Handlers\n        getCanvasDocument () {\n            const { props } = this;\n            return props.iframe.contentDocument;\n        },\n\n        getCanvasWindow () {\n            const { props } = this;\n            return props.iframe.contentWindow;\n        },\n\n        getCanvasBody () {\n            const { props } = this;\n            return props.iframe.contentDocument.body;\n        },\n\n        setContent (html) {\n            const canvasDoc = this.getCanvasDocument();\n\n            if (html instanceof Array) {\n                this.reset();\n                html.forEach((node) => {\n                    canvasDoc.body.appendChild(node);\n                });\n            } else {\n                canvasDoc.body.innerHTML = html;\n            }\n        },\n\n        insertRange (range) {\n            const rangeDocFrag = range.cloneContents();\n            const canvasBody = this.getCanvasBody();\n\n            this.reset();\n\n            for (let i = 0; i < rangeDocFrag.childNodes.length; i++) {\n                let childNode = rangeDocFrag.childNodes[i];\n                if (\n                    childNode.nodeType === Node.TEXT_NODE &&\n                    (\n                        !/\\w+/.test(childNode.textContent) ||\n                        zeroWidthSpace.assert(childNode)\n                    )\n                ) {\n                    rangeDocFrag.removeChild(childNode);\n                }\n            }\n\n            canvasBody.appendChild(rangeDocFrag);\n        },\n\n        insertNode (node) {\n            const nodeClone = node.cloneNode(true);\n            const canvasBody = this.getCanvasBody();\n            this.reset();\n            canvasBody.appendChild(nodeClone);\n        },\n\n        selectAll (opts={}) {\n            const { mediator } = this;\n            mediator.exec('selection:select:all', opts);\n        },\n\n        selectByCoordinates (rangeCoordinates) {\n            const { mediator } = this;\n            const canvasBody = this.getCanvasBody();\n\n            mediator.exec('selection:set:el', canvasBody);\n            mediator.exec('selection:select:coordinates', rangeCoordinates);\n        },\n\n        importSelection (opts={}) {\n            const { mediator } = this;\n            let rangeCoordinates;\n\n            if (opts.toRoot) {\n                rangeCoordinates = mediator.get('selection:range:relative:toroot');\n                mediator.exec('selection:expand:toroot');\n            }\n\n            const selectionRange = mediator.get('selection:range');\n\n            this.insertRange(selectionRange);\n            if (opts.toRoot) {\n                this.selectByCoordinates(rangeCoordinates);\n            } else {\n                this.selectAll();\n            }\n            this.setCanvasBodyEditable();\n\n        },\n\n        exportPrep () {\n            this.cleanHtml();\n        },\n\n        exportAll () {\n            const { mediator } = this;\n            const canvasBody = this.getCanvasBody();\n            // this.exportPrep();\n\n            let innerHTML = canvasBody.innerHTML;\n            innerHTML = innerHTML.replace(/\\s{2,}/g, ' ');\n            innerHTML = innerHTML.replace(/\\r?\\n|\\r/g, '');\n\n            mediator.exec('contenteditable:inserthtml', innerHTML);\n        },\n\n        getFormattedBlock () {\n            const { mediator } = this;\n            mediator.exec('selection:expand:toroot');\n            const blockRange = mediator.get('selection:range');\n            return blockRange.cloneContents();\n        },\n\n        cleanHtml () {\n            const canvasDoc = this.getCanvasDocument();\n            const canvasBody = this.getCanvasBody();\n            const walker = canvasDoc.createTreeWalker(canvasBody, NodeFilter.SHOW_ALL, null, false);\n\n            let allNodes = [];\n\n            while (walker.nextNode()) {\n                allNodes.push(walker.currentNode);\n            }\n\n            for (let i = allNodes.length - 1; i >= 0; i--) {\n                let node = allNodes[i];\n\n                if (\n                    !node.textContent ||\n                    !node.textContent.trim().length ||\n                    (zeroWidthSpace.assert(node))\n                ) {\n                    DOM.removeNode(node);\n                } else if (\n                    node.classList && node.classList.contains('typester-replace-default')\n                ) {\n                    let defaultNode = document.createElement('p');\n                    DOM.insertAfter(defaultNode, node);\n                    defaultNode.appendChild(node);\n                    DOM.unwrap(node);\n                } if (\n                    (node.classList && node.classList.contains('typester-container')) ||\n                    (node.nodeName === 'SPAN' && node.hasAttribute('style')) ||\n                    node.nodeName === 'FONT' || node.nodeName === 'DIV'\n                ) {\n                    DOM.unwrap(node);\n                }\n            }\n        },\n\n        getSelection () {\n            const { mediator } = this;\n            return mediator.get('selection:current');\n        },\n\n        getSelectionCoordinates () {\n            const { mediator } = this;\n            return mediator.get('selection:range:coordinates');\n        },\n\n        selectionInOrContains (selectors) {\n            const { mediator } = this;\n            return mediator.get('selection:in:or:contains', selectors);\n        },\n\n        destroy () {\n            const { props } = this;\n            const { iframe } = props;\n            iframe.parentNode.removeChild(iframe);\n        }\n    }\n});\n\nexport default Canvas;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/Canvas.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 79,
    "kind": "variable",
    "name": "Canvas",
    "memberof": "scripts/modules/Canvas.js",
    "static": true,
    "longname": "scripts/modules/Canvas.js~Canvas",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/Canvas.js",
    "importStyle": "Canvas",
    "description": "",
    "lineNumber": 12,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "file",
    "name": "scripts/modules/ContentEditable.js",
    "content": "// jshint strict: false\n\nimport Module from '../core/Module';\nimport DOM from '../utils/DOM';\nimport keycodes from '../utils/keycodes';\n\nimport contentEditableStyles from '../../styles/contentEditable.scss';\n\n/**\n* @access protected\n*/\nconst ContentEditable = Module({\n    name: 'ContentEditable',\n    props: {\n        styles: null,\n        cleanupTimeout: null\n    },\n    dom: {},\n    handlers: {\n        requests: {\n            'contenteditable:element': 'getContentEditableElement',\n            'contenteditable:toolbar:buttons': 'getToolbarButtons'\n        },\n        commands: {\n            'contenteditable:inserthtml' : 'insertHTML',\n            'contenteditable:refocus' : 'reFocus',\n            'contenteditable:cleanup' : 'cleanup'\n        },\n        domEvents: {\n            'focus' : 'handleFocus',\n            'keydown' : 'handleKeydown',\n            'keyup' : 'handleKeyup',\n            'blur' : 'handleBlur',\n            'paste' : 'handlePaste',\n            'mouseover' : 'handleMouseOver',\n            'mouseout' : 'handleMouseOut',\n            'click' : 'handleClick',\n            'input' : 'handleInput'\n        }\n    },\n    methods: {\n        setup () {\n            this.appendStyles();\n        },\n\n        init () {\n            this.ensureClass();\n            this.ensureEditable();\n            this.updatePlaceholderState();\n            this.updateValue();\n        },\n\n        appendStyles () {\n            const { props } = this;\n            props.styles = DOM.addStyles(contentEditableStyles);\n        },\n\n        ensureClass () {\n            const { dom } = this;\n            dom.el[0].classList.add('typester-content-editable');\n        },\n\n        updatePlaceholderState () {\n            const { dom } = this;\n            const rootEl = dom.el[0];\n\n            if (rootEl.hasAttribute('data-placeholder')) {\n                if (\n                    (rootEl.childNodes.length && rootEl.textContent.trim().length)\n                ) {\n                    rootEl.classList.remove('show-placeholder');\n                } else {\n                    rootEl.classList.add('show-placeholder');\n                }\n            }\n        },\n\n        updateValue () {\n            const { dom } = this;\n            const rootEl = dom.el[0];\n\n            if (rootEl.innerText.trim().length) {\n                rootEl.value = rootEl.innerHTML;\n            } else {\n                rootEl.value = '';\n            }\n        },\n\n        ensureEditable () {\n            const { dom } = this;\n            const rootEl = dom.el[0];\n\n            if (!rootEl.hasAttribute('contenteditable')) {\n                rootEl.contentEditable = true;\n            }\n        },\n\n        ensureDefaultBlock () {\n            const { dom, mediator } = this;\n            const rootEl = dom.el[0];\n\n            if (!/\\w+/.test(rootEl.textContent)) {\n                rootEl.innerHTML = '<p>&nbsp;</p>';\n                mediator.exec('selection:select:contents', rootEl.childNodes[0]);\n            }\n        },\n\n        getToolbarButtons () {\n            const { dom } = this;\n            const { toolbarButtons } = dom.el[0].dataset;\n            let buttonArray = [];\n\n            if (toolbarButtons) {\n                buttonArray = JSON.parse(toolbarButtons);\n            }\n\n            return buttonArray;\n        },\n\n        insertHTML (html) {\n            const { mediator } = this;\n\n            if (document.queryCommandSupported('insertHTML')) {\n                document.execCommand('insertHTML', null, html);\n            } else {\n                let currentSelection = mediator.get('selection:current');\n                let currentRange = mediator.get('selection:range');\n\n                currentRange.deleteContents();\n\n                let tmpContainer = document.createElement('container');\n                tmpContainer.innerHTML = html;\n\n                let docFrag = document.createDocumentFragment();\n                let node, lastNode;\n\n                while ((node = tmpContainer.firstChild)) {\n                    lastNode = docFrag.appendChild(node);\n                }\n                currentRange.insertNode(docFrag);\n\n                if (lastNode) {\n                    currentRange = currentRange.cloneRange();\n                    currentRange.setStartAfter(lastNode);\n                    currentRange.collapse(true);\n                    currentSelection.removeAllRanges();\n                    currentSelection.addRange(currentRange);\n                }\n            }\n        },\n\n        reFocus () {\n            const { dom } = this;\n            dom.el[0].focus();\n        },\n\n        getContentEditableElement () {\n            const { dom } = this;\n            return dom.el[0];\n        },\n\n        cleanup () {\n            const { dom, mediator } = this;\n            const rootEl = dom.el[0];\n            mediator.exec('format:clean', rootEl);\n        },\n\n        setCleanupTimeout () {\n            const { props } = this;\n            props.cleanupTimeout = setTimeout(() => {\n                this.cleanup();\n            }, 250);\n        },\n\n        clearCleanupTimeout () {\n            const { props } = this;\n            if (props.cleanupTimeout) {\n                clearTimeout(props.cleanupTimeout);\n                props.cleanupTimeout = null;\n            }\n        },\n\n        // DOM Event Handlers\n        handleFocus () {\n            const { mediator } = this;\n            this.clearCleanupTimeout();\n            this.ensureDefaultBlock();\n            this.updatePlaceholderState();\n            mediator.emit('contenteditable:focus');\n        },\n\n        handleKeyup (evnt) {\n            const { mediator, dom } = this;\n            const keyCode = evnt.which || evnt.keyCode;\n            const anchorNode = mediator.get('selection:anchornode');\n\n            function CustomEvent(event, params) {\n                var evt;\n                params = params || { bubbles: true, cancelable: true, detail: undefined };\n                evt = document.createEvent('CustomEvent');\n                evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n                return evt;\n            }\n\n            switch (keyCode) {\n            case keycodes.ENTER:\n                setTimeout(() => {\n                    mediator.emit('contenteditable:newline');\n                }, 100);\n                break;\n            case keycodes.BACKSPACE:\n                if (!anchorNode.textContent.trim().length || (anchorNode.hasAttribute && anchorNode.hasAttribute('contenteditable'))) {\n                    mediator.emit('contenteditable:newline');\n                }\n                break;\n            case keycodes.TAB:\n                mediator.emit('contenteditable:tab:up', evnt);\n                break;\n            }\n\n            dom.el[0].dispatchEvent(new CustomEvent('change'));\n\n            this.updateValue();\n            this.updatePlaceholderState();\n        },\n\n        handleKeydown (evnt) {\n            const { mediator } = this;\n            const keyCode = evnt.which || evnt.keyCode;\n\n            setTimeout(() => {\n                this.updatePlaceholderState();\n            }, 25);\n\n            switch (keyCode) {\n            case keycodes.TAB:\n                mediator.emit('contenteditable:tab:down', evnt);\n                break;\n            }\n        },\n\n        handleBlur () {\n            const { mediator } = this;\n            this.updatePlaceholderState();\n            this.updateValue();\n            this.setCleanupTimeout();\n            mediator.emit('contenteditable:blur');\n        },\n\n        handlePaste (evnt) {\n            const { mediator } = this;\n            mediator.emit('contenteditable:paste', evnt);\n            this.updateValue();\n        },\n\n        handleMouseOver (evnt) {\n            const { mediator } = this;\n            if (evnt.target.nodeName === 'A') {\n                mediator.emit('contenteditable:mouseover:anchor', evnt);\n            }\n        },\n\n        handleMouseOut (evnt) {\n            const { mediator } = this;\n            if (evnt.target.nodeName === 'A') {\n                mediator.emit('contenteditable:mouseout:anchor', evnt);\n            }\n        },\n\n        handleClick (evnt) {\n            const { dom } = this;\n            const rootEl = dom.el[0];\n\n            if (DOM.isIn(evnt.target, 'A', rootEl)) {\n                evnt.preventDefault();\n                evnt.stopPropagation();\n            }\n        },\n\n        handleInput () {\n            this.updateValue();\n        }\n    }\n});\n\nexport default ContentEditable;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/ContentEditable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 81,
    "kind": "variable",
    "name": "ContentEditable",
    "memberof": "scripts/modules/ContentEditable.js",
    "static": true,
    "longname": "scripts/modules/ContentEditable.js~ContentEditable",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/ContentEditable.js",
    "importStyle": "ContentEditable",
    "description": "",
    "lineNumber": 12,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "file",
    "name": "scripts/modules/Flyout.js",
    "content": "// jshint strict: false\nimport Module from '../core/Module';\nimport DOM from '../utils/DOM';\n\nimport flyoutTemplate from '../../templates/flyout.html';\nimport flyoutStyles from '../../styles/flyout.scss';\n\n/**\n* @access protected\n*/\nconst Flyout = Module({\n    name: 'Flyout',\n    dom: {},\n    props: {\n        minZIndex: 90,\n        styles: null,\n        flyouts: []\n    },\n    handlers: {\n        requests: {\n            'flyout:new' : 'newFlyout'\n        },\n        commands: {},\n        events: {\n            'app:destroy' : 'destroy'\n        }\n    },\n    methods: {\n        setup () {\n            this.appendStyles();\n        },\n\n        init () {},\n\n        appendStyles () {\n            const { props } = this;\n            props.styles = DOM.addStyles(flyoutStyles);\n        },\n\n        newFlyout () {\n            const { props } = this;\n            const flyout = this.buildFlyout();\n            props.flyouts.push(flyout);\n            return flyout;\n        },\n\n        buildFlyout () {\n            const flyout = {\n                el: this.buildTemplate(),\n                appended: null\n            };\n\n            flyout.contentEl = flyout.el.querySelector('.typester-flyout-content');\n\n            flyout.clearContent = () => {\n                flyout.contentEl.innerHTML = '';\n            };\n\n            flyout.appendContent = (content) => {\n                return DOM.appendTo(flyout.contentEl, content);\n            };\n            flyout.show = () => {\n                this.showFlyout(flyout);\n            };\n            flyout.remove = () => {\n                this.removeFlyout(flyout);\n            };\n            flyout.hide = () => {\n                this.hideFlyout(flyout);\n            };\n            flyout.position = (coordinates) => {\n                this.positionFlyout(flyout, coordinates);\n            };\n            flyout.setPlacement = (placement) => {\n                this.setPlacement(flyout, placement);\n            };\n\n            return flyout;\n        },\n\n        buildTemplate () {\n            const wrapperEl = document.createElement('div');\n            let flyoutHTML, flyoutEl;\n\n            flyoutHTML = flyoutTemplate();\n            if (typeof flyoutHTML === 'string') {\n                wrapperEl.innerHTML = flyoutHTML;\n            } else {\n                wrapperEl.appendChild(flyoutHTML[0]);\n            }\n            flyoutEl = wrapperEl.childNodes[0];\n\n            return flyoutEl;\n        },\n\n        appendFlyout (flyout) {\n            DOM.appendTo(document.body, flyout.el);\n        },\n\n        removeFlyout (flyout) {\n            if (flyout.appended) {\n                DOM.removeNode(flyout.el);\n                flyout.appended = false;\n            }\n        },\n\n        positionFlyout (flyout, coordinates) {\n            const { mediator, props } = this;\n            const contentEditableEl = mediator.get('contenteditable:element');\n            const containerZIndex = Math.max(props.minZIndex, DOM.getContainerZIndex(contentEditableEl));\n            console.log('positionFlyout', coordinates);\n            Object.keys(coordinates).forEach((coordinateKey) => {\n                flyout.el.style[coordinateKey] = coordinates[coordinateKey];\n            });\n\n            flyout.el.style.zIndex = containerZIndex + 1;\n        },\n\n        setPlacement (flyout, placement='above') {\n            flyout.el.classList.remove('place-below');\n            flyout.el.classList.remove('place-above');\n            flyout.el.classList.add(`place-${placement}`);\n        },\n\n        showFlyout (flyout) {\n            if (!flyout.appended) {\n                this.appendFlyout(flyout);\n                flyout.appended = true;\n            } else {\n                flyout.el.style.display = 'block';\n            }\n        },\n\n        hideFlyout (flyout) {\n            flyout.el.style.display = 'none';\n        },\n\n        destroy () {\n            const { props } = this;\n            props.flyouts.forEach((flyout) => {\n                flyout.remove();\n            });\n        }\n\n    }\n});\n\nexport default Flyout;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/Flyout.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 83,
    "kind": "variable",
    "name": "Flyout",
    "memberof": "scripts/modules/Flyout.js",
    "static": true,
    "longname": "scripts/modules/Flyout.js~Flyout",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/Flyout.js",
    "importStyle": "Flyout",
    "description": "",
    "lineNumber": 11,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "file",
    "name": "scripts/modules/Formatter.js",
    "content": "// jshint strict: false\n\nimport Module from '../core/Module';\nimport commands from '../utils/commands';\n\n/**\n* @access protected\n*/\nconst Formatter = Module({\n    name: 'Formatter',\n    requiredProps: ['contextWindow'],\n    props: {\n        contextWindow: null\n    },\n    handlers: {\n        commands: {\n            'format:default': 'formatDefault',\n            'format:block': 'formatBlock'\n        },\n        events: {\n            'contenteditable:keyup:enter' : 'handleNewLine'\n        }\n    },\n    methods: {\n        init () {\n        },\n\n        // Event Handlers\n        handleNewLine () {\n            this.formatDefault();\n        },\n\n        formatDefault () {\n            commands.defaultBlockFormat();\n        },\n\n        formatBlock (opts) {\n            commands.formatBlock(opts.style);\n        }\n    }\n});\n\nexport default Formatter;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/Formatter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 85,
    "kind": "variable",
    "name": "Formatter",
    "memberof": "scripts/modules/Formatter.js",
    "static": true,
    "longname": "scripts/modules/Formatter.js~Formatter",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/Formatter.js",
    "importStyle": "Formatter",
    "description": "",
    "lineNumber": 9,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "file",
    "name": "scripts/modules/LinkFormatter.js",
    "content": "// jshint strict: false\n\nimport Module from '../core/Module';\nimport commands from '../utils/commands';\nimport DOM from '../utils/DOM';\n\nimport inputFormTemplate from '../../templates/inputForm.html';\nimport linkDisplayTemplate from '../../templates/linkDisplay.html';\n\nimport inputFormStyles from '../../styles/inputForm.scss';\n\n/**\n* @access protected\n*/\nconst LinkFormatter = Module({\n    name: 'LinkFormatter',\n    props: {\n        urlRegex: /[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,4}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)/,\n        styles: null,\n        currentAnchor: null,\n        active: false,\n        hasMouse: false,\n        showing: null,\n        hideTimeout: null,\n        initialEvent: null,\n        targetEl: null,\n        hasRendered: null\n    },\n    dom: {\n        'userInput': '.user-input'\n    },\n    handlers: {\n        requests: {\n            'format:link:active': 'isActive'\n        },\n        commands: {\n            'format:link' : 'formatLink'\n        },\n        events: {\n            'app:destroy' : 'destroy',\n            'contenteditable:mouseover:anchor' : 'showLinkFlyout',\n            'contenteditable:mouseout:anchor' : 'hideFlyout',\n            'selection:update': 'handleSelectionChange',\n            'selection:change': 'handleSelectionChange',\n            'contenteditable:blur': 'handleContentEditableBlur'\n        },\n        domEvents: {\n            'submit' : 'handleSubmit',\n            'click' : 'handleClick',\n            'mouseover': 'handleMouseOver',\n            'mouseout' : 'handleMouseOut'\n        }\n    },\n    methods: {\n        setup () {\n            this.appendStyles();\n        },\n\n        appendStyles () {\n            const { props } = this;\n            props.styles = DOM.addStyles(inputFormStyles);\n        },\n\n        formatLink () {\n            if (this.isInLink()) {\n                this.removeLink();\n            } else {\n                this.showLinkFormFlyout();\n            }\n        },\n\n        isInLink () {\n            const { mediator } = this;\n            return mediator.get('selection:in:or:contains', ['A']);\n        },\n\n        showLinkFormFlyout (data) {\n            const { mediator, props } = this;\n            const linkForm = this.compileLinkForm(data);\n\n            props.showing = 'linkForm';\n            this.render({ content: linkForm });\n            mediator.exec('selection:wrap:pseudo');\n            this.focusInput();\n            this.bindInput();\n        },\n\n        showLinkFlyout (evnt) {\n            const { props, mediator } = this;\n            const anchor = DOM.getClosest(evnt.target, 'A');\n\n            if (\n                mediator.get('selection:contains:node', anchor) ||\n                props.showing === 'linkForm'\n            ) {\n                return;\n            }\n\n            this.clearHideTimeout();\n\n            const linkDisplay = this.compileLinkDisplay({ href: anchor.href });\n\n            props.initialEvent = evnt;\n            props.targetEl = anchor;\n            this.render({\n                content: linkDisplay,\n                flyoutPlacement: 'below'\n            });\n            props.showing = 'linkDisplay';\n            props.currentAnchor = anchor;\n        },\n\n        hideFlyout () {\n            const { props } = this;\n            props.hideTimeout = setTimeout(() => {\n                if (!this.isActive() && props.hasRendered) {\n                    this.destroy();\n                }\n            }, 350);\n        },\n\n        clearHideTimeout () {\n            const { props } = this;\n            if (props.hideTimeout) {\n                clearTimeout(props.hideTimeout);\n                props.hideTimeout = null;\n            }\n        },\n\n        compileLinkForm (data) {\n            const wrapperEl = document.createElement('div');\n            let inputFormHTML = inputFormTemplate(data);\n\n            if (typeof inputFormHTML === 'string') {\n                wrapperEl.innerHTML = inputFormHTML;\n            } else {\n                wrapperEl.appendChild(inputFormHTML[0]);\n            }\n\n            return wrapperEl.childNodes[0];\n        },\n\n        compileLinkDisplay (data) {\n            const wrapperEl = document.createElement('div');\n            let inputFormHTML = linkDisplayTemplate(data);\n\n            if (typeof inputFormHTML === 'string') {\n                wrapperEl.innerHTML = inputFormHTML;\n            } else {\n                wrapperEl.appendChild(inputFormHTML[0]);\n            }\n\n            return wrapperEl.childNodes[0];\n        },\n\n        render (opts) {\n            const { mediator, props } = this;\n\n            props.hasMouse = false;\n            props.flyout = props.flyout || mediator.get('flyout:new');\n            props.flyout.clearContent();\n            props.flyout.setPlacement(opts.flyoutPlacement);\n            props.flyout.appendContent(opts.content);\n\n            this.positionFlyout(opts);\n            this.showFlyout();\n\n            props.hasRendered = true;\n            return props.flyout.el;\n        },\n\n        positionFlyout (opts) {\n            const { mediator, props } = this;\n            const { initialEvent, targetEl } = props;\n            let targetBounds, elStyles, elLineHeight, lineCount, lineStepHeight;\n\n            if (targetEl) {\n                targetBounds = targetEl.getBoundingClientRect();\n                elStyles = window.getComputedStyle(targetEl);\n                elLineHeight = parseInt(elStyles.getPropertyValue('line-height'), 10);\n                lineCount = Math.ceil(targetBounds.height / elLineHeight);\n                lineStepHeight = targetBounds.height / lineCount;\n            } else {\n                targetBounds = mediator.get('selection:bounds');\n            }\n\n            if (targetBounds.width > 0) {\n                const scrollOffset = DOM.getScrollOffset();\n                let docRelTop, docRelCenter;\n\n                if (initialEvent) {\n                    const topDiff = initialEvent.clientY - targetBounds.top;\n\n                    docRelTop = initialEvent.clientY;\n                    docRelCenter = initialEvent.clientX;\n\n                    if (opts.flyoutPlacement === 'below') {\n                        docRelTop = targetBounds.top + (lineStepHeight * Math.ceil(topDiff / lineStepHeight));\n                    } else {\n                        docRelTop = targetBounds.top + (lineStepHeight * Math.floor(topDiff / lineStepHeight));\n                    }\n                } else {\n                    docRelTop = (opts.flyoutPlacement === 'below' ? targetBounds.bottom : targetBounds.top);\n                    docRelCenter = targetBounds.width / 2 + targetBounds.left + scrollOffset.x;\n                }\n\n                docRelTop += scrollOffset.y;\n\n                props.flyout.position({\n                    left: docRelCenter + 'px',\n                    top: docRelTop + 'px'\n                });\n            }\n        },\n\n        showFlyout () {\n            const { mediator, props } = this;\n            props.flyout.show();\n            mediator.exec('toolbar:hide');\n        },\n\n        focusInput () {\n            const { dom } = this;\n            dom.userInput[0].focus();\n        },\n\n        bindInput () {\n            const { dom, props } = this;\n            dom.userInput[0].addEventListener('blur', this.handleBlur);\n            props.userInputBound = true;\n        },\n\n        unbindInput () {\n            const { dom, props } = this;\n            if (props.userInputBound) {\n                props.userInputBound = false;\n                dom.userInput[0].removeEventListener('blur', this.handleBlur);\n            }\n        },\n\n        handleSubmit (evnt) {\n            evnt.preventDefault();\n            const formJSON = this.processForm();\n            if (formJSON['user-input']) {\n                this.createLink(formJSON);\n            } else {\n                this.removeLink({ byPseudo: true });\n            }\n        },\n\n        handleClick (evnt) {\n            const { mediator, props } = this;\n            if (evnt.target.nodeName === 'A') {\n                evnt.preventDefault();\n                mediator.exec('selection:wrap:element', props.currentAnchor, { silent: true });\n                this.showLinkFormFlyout({ value: props.currentAnchor.href });\n            }\n        },\n\n        handleMouseOver () {\n            const { props } = this;\n            props.hasMouse = true;\n        },\n\n        handleMouseOut () {\n            const { props } = this;\n            props.hasMouse = false;\n\n            if (props.showing === 'linkDisplay') {\n                this.hideFlyout();\n            }\n        },\n\n        handleBlur () {\n            const { props } = this;\n            if (props.blurTimeout) {\n                clearTimeout(props.blurTimeout);\n            }\n\n            props.blurTimeout = setTimeout(() => {\n                this.hideFlyout();\n            }, 100);\n        },\n\n        handleSelectionChange () {\n            if (\n                !this.isActive()\n            ) {\n                this.hideFlyout();\n            }\n        },\n\n        handleContentEditableBlur () {\n            this.hideFlyout();\n        },\n\n        isActive () {\n            const { props, dom } = this;\n            return props.hasMouse || (dom && document.activeElement === dom.userInput[0]) || props.showingLinkFlyout;\n        },\n\n        processForm () {\n            const { dom } = this;\n            const formInputs = dom.el[0].querySelectorAll('input, select, textarea');\n            let formJSON = {};\n\n            for (let i = 0; i < formInputs.length; i++) {\n                let inputEl = formInputs[i];\n                let inputName = inputEl.name;\n                let inputValue = inputEl.value;\n\n                if (inputName) {\n                    formJSON[inputName] = inputValue;\n                }\n            }\n\n            return formJSON;\n        },\n\n        processLinkInput (linkInput) {\n            const { props } = this;\n\n            if (props.urlRegex.test(linkInput) && linkInput.indexOf('//') < 0) {\n                linkInput = 'http://' + linkInput;\n            }\n\n            return linkInput;\n        },\n\n        createLink (formJSON) {\n            const { mediator } = this;\n\n            if (formJSON['user-input']) {\n                const linkURL = this.processLinkInput(formJSON['user-input']);\n                mediator.exec('selection:select:pseudo');\n                commands.exec('unlink');\n                commands.exec('createLink', linkURL);\n            }\n\n            this.destroy();\n        },\n\n        removeLink (opts={}) {\n            const { mediator } = this;\n\n            if (opts.byPseudo) {\n                mediator.exec('selection:select:pseudo');\n            } else {\n                const anchorNode = mediator.get('selection:anchornode');\n                const anchor = DOM.getClosest(anchorNode, 'A');\n                mediator.exec('selection:wrap:element', anchor);\n            }\n\n            commands.exec('unlink');\n            this.destroy();\n        },\n\n        destroy () {\n            const { props, mediator } = this;\n            if (props.flyout) {\n                this.unbindInput();\n                props.flyout.remove();\n            }\n            props.showing = null;\n            props.hasMouse = false;\n            props.hasRendered = null;\n            mediator.exec('selection:select:remove:pseudo');\n        }\n    }\n});\n\nexport default LinkFormatter;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/LinkFormatter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 87,
    "kind": "variable",
    "name": "LinkFormatter",
    "memberof": "scripts/modules/LinkFormatter.js",
    "static": true,
    "longname": "scripts/modules/LinkFormatter.js~LinkFormatter",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/LinkFormatter.js",
    "importStyle": "LinkFormatter",
    "description": "",
    "lineNumber": 15,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "file",
    "name": "scripts/modules/ListFormatter.js",
    "content": "// jshint strict: false\n\nimport Module from '../core/Module';\nimport commands from '../utils/commands';\nimport DOM from '../utils/DOM';\n\n/**\n* @access protected\n*/\nconst ListFormatter = Module({\n    name: 'ListFormatter',\n    props: {},\n    dom: {},\n    handlers: {\n        requests: {},\n        commands: {\n            'format:list': 'formatList',\n            'format:list:cleanup': 'cleanupListDOM'\n        },\n        events: {\n            'contenteditable:tab:down': 'handleTabDown',\n            'contenteditable:tab:up': 'handleTabUp'\n        }\n    },\n    methods: {\n        init () {},\n        formatList (opts) {\n            this.preProcess(opts);\n            this.process(opts);\n            this.commit(opts);\n        },\n\n        preProcess () {\n            const { mediator } = this;\n            mediator.exec('format:export:to:canvas');\n        },\n\n        process (opts) {\n            const { mediator } = this;\n            const canvasDoc = mediator.get('canvas:document');\n            let toggle = false;\n\n            mediator.exec('canvas:cache:selection');\n            switch (opts.style) {\n            case 'ordered':\n                toggle = mediator.get('selection:in:or:contains', ['OL']);\n                if (toggle) {\n                    // this.prepListItemsForToggle();\n                    // while (mediator.get('canvas:selection:in:or:contains', ['OL'])) {\n                    //     commands.exec('outdent', null, canvasDoc);\n                    // }\n                    // commands.exec('insertOrderedList', null, canvasDoc);\n                    // return;\n                } else if (mediator.get('selection:in:or:contains', ['UL'])) {\n                    commands.exec('insertUnorderedList', null, canvasDoc);\n                }\n                commands.exec('insertOrderedList', null, canvasDoc);\n                break;\n            case 'unordered':\n                toggle = mediator.get('selection:in:or:contains', ['UL']);\n                if (toggle) {\n                    // this.prepListItemsForToggle();\n                    // while (mediator.get('canvas:selection:in:or:contains', ['UL'])) {\n                    //     commands.exec('outdent', null, canvasDoc);\n                    // }\n                    // commands.exec('insertUnorderedList', null, canvasDoc);\n                    // return;\n                }\n                if (mediator.get('selection:in:or:contains', ['OL'])) {\n                    commands.exec('insertOrderedList', null, canvasDoc);\n                }\n                commands.exec('insertUnorderedList', null, canvasDoc);\n                break;\n            case 'outdent':\n                commands.exec('outdent', null, canvasDoc);\n                break;\n            case 'indent':\n                commands.exec('indent', null, canvasDoc);\n                break;\n            }\n\n            if (toggle) {\n                // mediator.exec('canvas:select:cachedSelection');\n                this.postProcessToggle(opts);\n            } else {\n                mediator.exec('canvas:select:ensure:offsets');\n            }\n\n            // mediator.exec('canvas:select:cachedSelection');\n        },\n\n        commit () {\n            const { mediator, cleanupListDOM } = this;\n            mediator.exec('format:import:from:canvas', {\n                importFilter: cleanupListDOM\n            });\n        },\n\n        handleTabDown (evnt) {\n            const { mediator } = this;\n            const isInList = mediator.get('selection:in:or:contains', ['UL', 'OL']);\n\n            if (isInList) {\n                evnt.preventDefault();\n            }\n        },\n\n        handleTabUp (evnt) {\n            const { mediator } = this;\n            const isInList = mediator.get('selection:in:or:contains', ['UL', 'OL']);\n\n\n            if (isInList) {\n                evnt.preventDefault();\n\n                if (evnt.shiftKey) {\n                    // this.formatList({ style: 'outdent' });\n                } else {\n                    // this.formatList({ style: 'indent' });\n                }\n            }\n        },\n\n        prepListItemsForToggle () {\n            const { mediator } = this;\n\n            const canvasDoc = mediator.get('canvas:document');\n            const canvasBody = mediator.get('canvas:body');\n\n            const {\n                anchorNode,\n                focusNode,\n            } = mediator.get('canvas:selection');\n\n            const anchorLiNode = DOM.getClosest(anchorNode, 'LI', canvasBody);\n            const focusLiNode = DOM.getClosest(focusNode, 'LI', canvasBody);\n\n            mediator.exec('canvas:cache:selection');\n\n            let selectedLiNodes = [anchorLiNode];\n            let nextLiNode = anchorLiNode.nextSibling;\n            while (nextLiNode && nextLiNode !== focusLiNode) {\n                selectedLiNodes.push(nextLiNode);\n                nextLiNode = nextLiNode.nextSibling;\n            }\n            selectedLiNodes.push(focusLiNode);\n\n            selectedLiNodes.forEach((selectedLiNode) => {\n                let contentWrapper = canvasDoc.createElement('span');\n                selectedLiNode.appendChild(contentWrapper);\n                while (selectedLiNode.firstChild !== contentWrapper) {\n                    contentWrapper.appendChild(selectedLiNode.firstChild);\n                }\n            });\n\n            mediator.exec('canvas:select:cachedSelection');\n\n            return;\n            // const canvasBody = mediator.get('canvas:body');\n            // const canvasDoc = mediator.get('canvas:document');\n            //\n            // let rootBlock = anchorNode;\n            // while(rootBlock.parentNode !== canvasBody) {\n            //     rootBlock = rootBlock.parentNode;\n            // }\n            //\n            // const liNodes = rootBlock.querySelectorAll('li');\n            // liNodes.forEach((liNode) => {\n            //     let pNode = canvasDoc.createElement('span');\n            //     liNode.appendChild(pNode);\n            //     while (liNode.firstChild !== pNode) {\n            //         pNode.appendChild(liNode.firstChild);\n            //     }\n            // });\n        },\n\n        postProcessToggle () {\n            const { mediator } = this;\n            // return;\n\n            const canvasDoc = mediator.get('canvas:document');\n            const canvasBody = mediator.get('canvas:body');\n\n            mediator.exec('canvas:cache:selection');\n\n            const {\n                anchorNode,\n                focusNode\n            } = mediator.get('canvas:selection');\n\n            const walkToRoot = function (node) {\n                let rootNode = node;\n                while ( rootNode.parentNode !== canvasBody ) {\n                    rootNode = rootNode.parentNode;\n                }\n                return rootNode;\n            };\n\n            const anchorRootNode = walkToRoot(anchorNode);\n            const focusRootNode = walkToRoot(focusNode);\n\n            let currentNode = anchorRootNode;\n            let currentParagraph;\n\n            const createParagraph = function () {\n                currentParagraph = canvasDoc.createElement('p');\n                DOM.insertBefore(currentParagraph, currentNode);\n            };\n\n            const handleBrNode = function (brNode) {\n                createParagraph();\n                currentNode = brNode.nextSibling;\n                DOM.removeNode(brNode);\n            };\n\n            const handleDivNode = function (divNode) {\n                createParagraph();\n                currentNode = divNode.nextSibling;\n                while (divNode.firstChild) {\n                    currentParagraph.appendChild(divNode.firstChild);\n                }\n                DOM.removeNode(divNode);\n            };\n\n            createParagraph();\n\n            while (currentNode !== focusRootNode) {\n                if (currentNode.nodeName === 'BR') {\n                    handleBrNode(currentNode);\n                } else if (currentNode.nodeName === 'DIV') {\n                    handleDivNode(currentNode);\n                } else {\n                    let orphanedNode = currentNode;\n                    currentNode = currentNode.nextSibling;\n                    currentParagraph.appendChild(orphanedNode);\n                }\n            }\n\n            if (focusRootNode.nodeName === 'DIV') {\n                handleDivNode(focusRootNode);\n            } else {\n                currentParagraph.appendChild(focusRootNode);\n            }\n\n            mediator.exec('canvas:select:cachedSelection');\n        },\n\n        cleanupListDOM (rootElem) {\n            const listContainers = rootElem.querySelectorAll('OL, UL');\n\n            for (let i = listContainers.length - 1; i >= 0; i--) {\n                let listContainer = listContainers[i];\n                if (['OL', 'UL'].indexOf(listContainer.parentNode.nodeName) > -1) {\n                    if (listContainer.previousSibling) {\n                        if (listContainer.previousSibling.nodeName === 'LI') {\n                            listContainer.previousSibling.appendChild(listContainer);\n                        }\n\n                        if (['OL', 'UL'].indexOf(listContainer.previousSibling.nodeName) > -1) {\n                            for (let j = 0; j <= listContainer.childNodes.length; j++) {\n                                listContainer.previousSibling.appendChild(listContainer.childNodes[j]);\n                            }\n                            DOM.removeNode(listContainer);\n                        }\n                    } else {\n                        DOM.unwrap(listContainer);\n                    }\n                } else {\n                    while (listContainer.parentNode && listContainer.parentNode !== rootElem && ['LI'].indexOf(listContainer.parentNode.nodeName) < 0) {\n                        DOM.insertBefore(listContainer, listContainer.parentNode);\n                    }\n                }\n            }\n\n            const nestedListItems = rootElem.querySelectorAll('LI > LI');\n            for (let i = nestedListItems.length - 1; i >= 0; i--) {\n                let nestedListItem = nestedListItems[i];\n                DOM.insertAfter(nestedListItem, nestedListItem.parentNode);\n            }\n        }\n    }\n});\n\nexport default ListFormatter;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/ListFormatter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 89,
    "kind": "variable",
    "name": "ListFormatter",
    "memberof": "scripts/modules/ListFormatter.js",
    "static": true,
    "longname": "scripts/modules/ListFormatter.js~ListFormatter",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/ListFormatter.js",
    "importStyle": "ListFormatter",
    "description": "",
    "lineNumber": 10,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "file",
    "name": "scripts/modules/Mouse.js",
    "content": "// jshint strict: false\n\nimport Module from '../core/Module';\n\n/**\n* @access protected\n*/\nconst Mouse = Module({\n    name: 'Mouse',\n    props: {\n        mousedown: 0\n    },\n    dom: {},\n    handlers: {\n        requests: {\n            'mouse:is:down': 'mouseIsDown'\n        },\n        commands: {},\n        events: {\n            'contenteditable:blur': 'handleContentEditableBlur'\n        }\n    },\n    methods: {\n        init () {\n            const { mediator } = this;\n            document.body.onmousedown = () => {\n                this.setMousedown();\n                mediator.emit('mouse:down');\n            };\n            document.body.onmouseup = () => {\n                this.unsetMousedown();\n                mediator.emit('mouse:up');\n            };\n            // document.body.onmouseout = () => {\n            //     props.mousedown = 0;\n            // };\n        },\n\n        setMousedown () {\n            const { props } = this;\n            props.mousedown += 1;\n            props.mousedown = Math.min(1, props.mousedown);\n        },\n\n        unsetMousedown () {\n            const { props } = this;\n            props.mousedown -= 1;\n            props.mousedown = Math.max(0, props.mousedown);\n        },\n\n        mouseIsDown () {\n            const { props } = this;\n            return !!props.mousedown;\n        },\n\n        handleContentEditableBlur () {\n            const { props } = this;\n            props.mousedown = 0;\n        }\n    }\n});\n\nexport default Mouse;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/Mouse.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 91,
    "kind": "variable",
    "name": "Mouse",
    "memberof": "scripts/modules/Mouse.js",
    "static": true,
    "longname": "scripts/modules/Mouse.js~Mouse",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/Mouse.js",
    "importStyle": "Mouse",
    "description": "",
    "lineNumber": 8,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "file",
    "name": "scripts/modules/Paste.js",
    "content": "// jshint strict: false\n\nimport DOMPurify from 'dompurify';\n\nimport Module from '../core/Module';\nimport pasteUtils from '../utils/paste';\nimport DOM from '../utils/DOM';\n\n/**\n* @access protected\n*/\nconst Paste = Module({\n    name: 'Paste',\n    props: {},\n    handlers: {\n        commands: {},\n        requests: {},\n        events: {\n            'contenteditable:paste': 'handlePaste'\n        }\n    },\n    methods: {\n        init () {\n\n        },\n\n        handlePaste (evnt) {\n            evnt.preventDefault();\n\n            const { mediator } = this;\n            let {\n                'text/html': pastedHTML,\n                'text/plain': pastedPlain\n            } = this.getClipboardContent(evnt, window, document);\n\n            if (!pastedHTML) {\n                pastedHTML = pastedPlain.replace(/(?:\\r\\n|\\r|\\n)/g, '<br />');\n            }\n\n            pastedHTML = this.cleanPastedHTML(pastedHTML);\n            pastedHTML = DOMPurify.sanitize(pastedHTML);\n\n            mediator.exec('contenteditable:inserthtml', pastedHTML);\n        },\n\n        getClipboardContent (evnt, contextWindow, contextDocument) {\n            const dataTransfer = evnt.clipboardData || contextWindow.clipboardData || contextDocument.dataTransfer;\n            let data = {\n                pastedHTML: '',\n                pastedPlain: ''\n            };\n\n            if (!dataTransfer) {\n                return data;\n            }\n\n            if (dataTransfer.getData) {\n                let legacyText = dataTransfer.getData('text');\n                if (legacyText && legacyText.length > 0) {\n                    data['text/plain'] = legacyText;\n                }\n            }\n\n            if (dataTransfer.types) {\n                for (let i = 0; i < dataTransfer.types.length; i++) {\n                    let contentType = dataTransfer.types[i];\n                    data[contentType] = dataTransfer.getData(contentType);\n                }\n            }\n\n            return data;\n        },\n\n        cleanPastedHTML (pastedHTML) {\n            const { mediator } = this;\n            const canvasDoc = mediator.get('canvas:document');\n            const canvasBody = mediator.get('canvas:body');\n            const replacements = pasteUtils.createReplacements();\n\n            for (let i = 0; i < replacements.length; i++) {\n                let replacement = replacements[i];\n                pastedHTML = pastedHTML.replace(replacement[0], replacement[1]);\n            }\n\n            canvasBody.innerHTML = '<p>' + pastedHTML.split('<br><br>').join('</p><p>') + '</p>';\n\n            let elList = canvasBody.querySelectorAll('a,p,div,br');\n            for (let i = 0; i < elList.length; i++) {\n                let workEl = elList[i];\n\n                workEl.innerHTML = workEl.innerHTML.replace(/\\n/gi, ' ');\n            }\n\n            const pasteBlock = canvasDoc.createDocumentFragment();\n            const pasteBlockBody = canvasDoc.createElement('body');\n            pasteBlock.appendChild(pasteBlockBody);\n            pasteBlockBody.innerHTML = canvasBody.innerHTML;\n\n            this.cleanupSpans(pasteBlockBody);\n            this.cleanupDivs(pasteBlockBody);\n\n            elList = pasteBlockBody.querySelectorAll('*');\n            for (let i = 0; i < elList.length; i++) {\n                let workEl = elList[i];\n                let elAttrs = [];\n\n                for (let j = 0; j < workEl.attributes.length; j++) {\n                    elAttrs.push(workEl.attributes[j].name);\n                }\n\n                for (let k = 0; k < elAttrs.length; k++) {\n                    let attrName = elAttrs[k];\n                    if (!(workEl.nodeName === 'A' && attrName === 'href')) {\n                        workEl.removeAttribute(attrName);\n                    }\n                }\n            }\n\n            canvasBody.innerHTML = pasteBlockBody.innerHTML;\n            mediator.exec('format:list:cleanup', canvasBody);\n            mediator.exec('format:clean', canvasBody);\n\n            pastedHTML = canvasBody.innerHTML;\n            return pastedHTML;\n        },\n\n        cleanupSpans (containerEl) {\n            let spans = containerEl.querySelectorAll('.replace-with');\n\n            for (let i = 0; i < spans.length; i++) {\n                let span = spans[i];\n                let replaceBold = span.classList.contains('bold');\n                let replaceItalic = span.classList.contains('italic');\n                let replacement = document.createElement(replaceBold ? 'b' : 'i');\n\n                if (replaceBold && replaceItalic) {\n                    replacement.innerHTML = '<i>' + span.innerHTML + '</i>';\n                } else {\n                    replacement.innerHTML = span.innerHTML;\n                }\n\n                span.parentNode.replaceChild(replacement, span);\n            }\n\n            spans = containerEl.querySelectorAll('span');\n            for (let i = 0; i < spans.length; i++) {\n                let span = spans[i];\n                DOM.unwrap(span);\n            }\n        },\n\n        cleanupDivs (containerEl) {\n            let divs = containerEl.querySelectorAll('div');\n            for (let i = divs.length - 1; i >=0; i--) {\n                DOM.unwrap(divs[i]);\n            }\n        }\n    }\n});\n\nexport default Paste;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/Paste.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 93,
    "kind": "variable",
    "name": "Paste",
    "memberof": "scripts/modules/Paste.js",
    "static": true,
    "longname": "scripts/modules/Paste.js~Paste",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/Paste.js",
    "importStyle": "Paste",
    "description": "",
    "lineNumber": 12,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "file",
    "name": "scripts/modules/Selection.js",
    "content": "// jshint strict: false\n\nimport Module from '../core/Module';\nimport formattersConfig from '../config/formatters';\nimport toolbarConfig from '../config/toolbar';\n\nimport DOM from '../utils/DOM';\n\n/**\n* @access protected\n*/\nconst Selection = Module({\n    name: 'Selection',\n    props: {\n        contextWindow: window,\n        contextDocument: document,\n        cachedSelection: null,\n        cachedRange: null,\n        pseudoSelection: null,\n        silenceChanges: []\n    },\n    dom: {\n        el: null\n    },\n    handlers: {\n        requests: {\n            'selection:current': 'getCurrentSelection',\n            'selection:range': 'getCurrentRange',\n            'selection:anchornode': 'getAnchorNode',\n            'selection:commonancestor': 'getCommonAncestor',\n            'selection:closestblock': 'getClosestBlock',\n            'selection:rootelement': 'getRootElement',\n            'selection:range:clone': 'getRangeClone',\n            'selection:bounds': 'getSelectionBounds',\n            'selection:range:relative:toroot': 'getRangeRelativeToRoot',\n            'selection:in:or:contains': 'inOrContains',\n            'selection:range:coordinates': 'rangeCoordinates',\n            'selection:contains:node': 'containsNode',\n            'selection:spans:multiple:blocks': 'spansMultipleBlocks'\n        },\n\n        commands: {\n            'selection:set:contextWindow': 'setContextWindow',\n            'selection:set:contextDocument': 'setContextDocument',\n            'selection:set:el': 'setRootElement',\n            'selection:expand:toroot': 'expandToRoot',\n            'selection:update:range': 'updateRange',\n            'selection:wrap:element': 'wrapElement',\n            'selection:wrap:content': 'wrapContent',\n            'selection:wrap:pseudo': 'wrapPseudoSelect',\n            'selection:select:pseudo': 'selectPseudo',\n            'selection:select:remove:pseudo': 'removePseudo',\n            'selection:collapse:tostart': 'collapseToStart',\n            'selection:reselect': 'reSelect',\n            'selection:select:contents': 'selectContents',\n            'selection:collapse:toend': 'collapseToEnd',\n            'selection:select:all': 'selectAll',\n            'selection:select:coordinates': 'selectByCoordinates',\n            'selection:ensure:text:only' : 'ensureTextOnlySelection',\n            'selection:deselect': 'deSelect'\n        }\n    },\n    methods: {\n        init () {\n            this.bindDocumentEvents();\n        },\n\n        bindDocumentEvents () {\n            const { contextDocument } = this.props;\n            contextDocument.addEventListener('selectstart', this.handleSelectStart);\n            contextDocument.addEventListener('selectionchange', this.handleSelectionChange);\n        },\n\n        unbindDocumentEvents () {\n            const { contextDocument } = this.props;\n            contextDocument.removeEventListener('selectstart', this.handleSelectStart);\n            contextDocument.removeEventListener('selectionchange', this.handleSelectionChange);\n        },\n\n        setContextWindow (contextWindow) {\n            const { props } = this;\n            props.contextWindow = contextWindow;\n        },\n\n        setContextDocument (contextDocument) {\n            const { props } = this;\n            this.unbindDocumentEvents();\n            props.contextDocument = contextDocument;\n            this.bindDocumentEvents();\n        },\n\n        setRootElement (elem) {\n            const { dom } = this;\n            dom.el = [elem];\n        },\n\n        handleSelectStart (evnt) {\n            const { mediator } = this;\n            const { el } = this.dom;\n            const anchorNode = this.getAnchorNode();\n\n            if (DOM.isChildOf(anchorNode, el)) {\n                mediator.emit('selection:start', evnt);\n            }\n        },\n\n        handleSelectionChange (evnt) {\n            const { mediator, props } = this;\n            const { el } = this.dom;\n            const anchorNode = this.getAnchorNode();\n\n            if (DOM.isChildOf(anchorNode, el)) {\n                this.cacheRange();\n                if (!props.silenceChanges.length) {\n                    mediator.emit('selection:change', evnt);\n                } else {\n                    props.silenceChanges.pop();\n                }\n            }\n        },\n\n        cacheRange () {\n            const currentRange = this.getCurrentRange();\n            this.props.cachedRange = currentRange.cloneRange();\n        },\n\n        getCurrentSelection () {\n            const { contextWindow } = this.props;\n            return contextWindow.getSelection();\n        },\n\n        validateSelection (selection) {\n            const { dom } = this;\n            return selection.anchorNode && DOM.isChildOf(selection.anchorNode, dom.el);\n        },\n\n        getCurrentRange () {\n            const { props } = this;\n            const currentSelection = this.getCurrentSelection();\n            let currentRange;\n\n            if (this.validateSelection(currentSelection)) {\n                currentRange = currentSelection.getRangeAt(0);\n            } else if (props.cachedRange) {\n                currentRange = props.cachedRange;\n            } else {\n                currentRange = document.createRange();\n            }\n\n            return currentRange;\n        },\n\n        getAnchorNode () {\n            const currentSelection = this.getCurrentSelection();\n            return currentSelection.anchorNode;\n        },\n\n        getCommonAncestor () {\n            const currentSelection = this.getCurrentSelection();\n            if (currentSelection.rangeCount > 0) {\n                const selectionRange = currentSelection.getRangeAt(0);\n                return selectionRange.commonAncestorContainer;\n            }\n        },\n\n        getClosestBlock () {\n            const commonAncestor = this.getCommonAncestor();\n            let closestBlockEl = null;\n            let currentNode = commonAncestor;\n\n            while (!closestBlockEl && !this.isContentEditable(currentNode) && currentNode) {\n                if (currentNode.nodeType === Node.ELEMENT_NODE) {\n                    let nodeTagName = currentNode.tagName.toLowerCase();\n                    if (formattersConfig.base.blockElementNames.indexOf(nodeTagName) > -1) {\n                        closestBlockEl = currentNode;\n                    } else {\n                        currentNode = currentNode.parentNode;\n                    }\n                } else {\n                    currentNode = currentNode.parentNode;\n                }\n            }\n\n            return closestBlockEl;\n        },\n\n        getRootElement () {\n            const { dom } = this;\n            return dom.el[0];\n        },\n\n        getRangeClone () {\n            const currentRange = this.getCurrentRange();\n            return currentRange.cloneRange();\n        },\n\n        getRangeRelativeToRoot () {\n            let {\n                startContainer,\n                startOffset,\n                endContainer,\n                endOffset\n            } = this.getCurrentRange();\n            let startCoordinates = [];\n            let endCoordinates = [];\n            let startRootChildIndex = 0;\n\n            startCoordinates.unshift(startOffset);\n            endCoordinates.unshift(endOffset);\n\n            while (!this.isContentEditable(startContainer)) {\n                if (this.isContentEditable(startContainer.parentNode)) {\n                    startRootChildIndex = DOM.childIndex(startContainer);\n                    startCoordinates.unshift(0);\n                } else {\n                    startCoordinates.unshift(DOM.childIndex(startContainer));\n                }\n                startContainer = startContainer.parentNode;\n            }\n\n            while (!this.isContentEditable(endContainer)) {\n                if (this.isContentEditable(endContainer.parentNode)) {\n                    endCoordinates.unshift(DOM.childIndex(endContainer) - startRootChildIndex);\n                } else {\n                    endCoordinates.unshift(DOM.childIndex(endContainer));\n                }\n                endContainer = endContainer.parentNode;\n            }\n\n            return {\n                startCoordinates,\n                endCoordinates\n            };\n        },\n\n        rangeCoordinates () {\n            this.ensureTextOnlySelection();\n\n            let {\n                startContainer,\n                startOffset,\n                endContainer,\n                endOffset\n            } = this.getCurrentRange();\n            let startCoordinates = [];\n            let endCoordinates = [];\n\n            startCoordinates.unshift(startOffset);\n            endCoordinates.unshift(endOffset);\n\n            while (!this.isContentEditable(startContainer)) {\n                startCoordinates.unshift(DOM.childIndex(startContainer));\n                startContainer = startContainer.parentNode;\n            }\n\n            while (!this.isContentEditable(endContainer)) {\n                endCoordinates.unshift(DOM.childIndex(endContainer));\n                endContainer = endContainer.parentNode;\n            }\n\n            return {\n                startCoordinates,\n                endCoordinates\n            };\n        },\n\n        inOrContains (selectors) {\n            const { dom } = this;\n            const rootEl = dom.el[0];\n            const anchorNode = this.getAnchorNode();\n\n            if (!rootEl.contains(anchorNode)) {\n                return false;\n            }\n\n            const isIn = DOM.isIn(anchorNode, selectors, rootEl);\n\n            if (isIn) {\n                return isIn;\n            }\n\n            const currentRange = this.getCurrentRange();\n            const rangeFrag = currentRange.cloneContents();\n            let contains = false;\n\n            if (rangeFrag.childNodes.length) {\n                selectors.forEach(selector => {\n                    contains = contains || rangeFrag.childNodes[0].nodeName === selector;\n                });\n            }\n\n            return contains;\n        },\n\n        containsNode (node) {\n            const currentSelection = this.getCurrentSelection();\n            let { anchorNode, focusNode } = currentSelection;\n            const selectionContainsNode = currentSelection.containsNode(node, true);\n\n            if (!currentSelection.rangeCount) {\n                return false;\n            }\n\n            if (selectionContainsNode) {\n                return true;\n            }\n\n            if (anchorNode.nodeType !== Node.ELEMENT_NODE) {\n                anchorNode = anchorNode.parentNode;\n            }\n            if (focusNode.nodeType !== Node.ELEMENT_NODE) {\n                focusNode = focusNode.parentNode;\n            }\n\n            return anchorNode === node || focusNode === node;\n        },\n\n        expandToRoot (opts={}) {\n            const currentRange = opts.range || this.getCurrentRange();\n            let startRootNode = currentRange.startContainer;\n            let endRootNode = currentRange.endContainer;\n            const newRange = document.createRange();\n            const startEqualsEnd = startRootNode === endRootNode;\n\n            if (this.isContentEditable(startRootNode)) {\n                return;\n            }\n\n            const getRootEl = (node) => {\n                let currentNode = node;\n                if (!this.isContentEditable(currentNode)) {\n                    while (currentNode.parentNode && !this.isContentEditable(currentNode.parentNode)) {\n                        currentNode = currentNode.parentNode;\n                    }\n                }\n                return currentNode;\n            };\n\n            startRootNode = getRootEl(startRootNode);\n            endRootNode = startEqualsEnd ? startRootNode : getRootEl(endRootNode);\n\n            if (opts.innerBounds) {\n                newRange.setStartAfter(startRootNode);\n                newRange.setEndBefore(endRootNode);\n            } else {\n                newRange.setStart(startRootNode, 0);\n                newRange.setEndAfter(endRootNode);\n            }\n\n            this.updateRange(newRange, { silent:true });\n        },\n\n        wrapElement (elem, opts={}) {\n            const currentRange = this.getCurrentRange();\n\n            if (elem instanceof Array) {\n                currentRange.setStartBefore(elem[0]);\n                currentRange.setEndAfter(elem[elem.length - 1]);\n            } else if (elem.nodeType === Node.ELEMENT_NODE) {\n                currentRange.setStartBefore(elem);\n                currentRange.setEndAfter(elem);\n            }\n\n            this.updateRange(currentRange, opts);\n        },\n\n        wrapContent () {\n            const currentRange = this.getCurrentRange();\n            const selectionRootEl = this.getRootElement();\n            currentRange.selectNodeContents(selectionRootEl);\n            this.updateRange(currentRange);\n        },\n\n        wrapPseudoSelect () {\n            const { props } = this;\n            const currentRange = this.getCurrentRange();\n\n            const pseudoSelection = document.createElement('span');\n            pseudoSelection.classList.add('typester-pseudo-selection');\n            pseudoSelection.appendChild(currentRange.extractContents());\n            currentRange.insertNode(pseudoSelection);\n\n            props.pseudoSelection = pseudoSelection;\n            this.wrapElement(pseudoSelection);\n        },\n\n        selectPseudo () {\n            const { dom } = this;\n            const unwrappedNodes = this.removePseudo();\n\n            if (unwrappedNodes.length) {\n                dom.el[0].focus();\n                this.wrapElement(unwrappedNodes, { silent: true });\n            }\n        },\n\n        removePseudo () {\n            const { props } = this;\n            let unwrappedNodes = [];\n\n            if (\n                props.pseudoSelection &&\n                props.pseudoSelection.tagName\n            ) {\n                unwrappedNodes = DOM.unwrap(props.pseudoSelection);\n                props.pseudoSelection = null;\n            }\n\n            return unwrappedNodes;\n        },\n\n        selectContents (node) {\n            const newRange = document.createRange();\n\n            if (node.childNodes.length) {\n                newRange.selectNodeContents(node);\n            } else {\n                newRange.setStart(node, 0);\n                newRange.collapse(true);\n            }\n\n            this.updateRange(newRange);\n        },\n\n        updateRange (range, opts={}) {\n            const { mediator, props } = this;\n            const currentSelection = this.getCurrentSelection();\n\n            if (opts.silent) {\n                props.silenceChanges.push(true); // silence removeAllRanges\n                props.silenceChanges.push(true); // silence addRange\n            }\n\n            currentSelection.removeAllRanges();\n            currentSelection.addRange(range);\n\n            if (!opts.silent) {\n                mediator.emit('selection:update');\n            }\n        },\n\n        deSelect () {\n            const currentSelection = this.getCurrentSelection();\n            currentSelection.removeAllRanges();\n        },\n\n        isContentEditable (node) {\n            return node && node.nodeType === Node.ELEMENT_NODE && node.hasAttribute('contenteditable');\n        },\n\n        getSelectionBounds () {\n            const currentRange = this.getCurrentRange();\n            const rangeRects = currentRange ? currentRange.getClientRects() : [];\n            const rangeBoundingClientRect = currentRange ? currentRange.getBoundingClientRect() : null;\n\n            let selectionBounds = {\n                top: null,\n                right: null,\n                bottom: null,\n                left: null,\n                height: null,\n                width: null,\n                initialWidth: null,\n                initialLeft: null\n            };\n\n            const setSelectionBoundary = function (rangeRect) {\n                ['top', 'left', 'bottom', 'right', 'height', 'width'].forEach((rectKey) => {\n                    if (!selectionBounds[rectKey]) {\n                        selectionBounds[rectKey] = rangeRect[rectKey];\n                    } else {\n                        switch (rectKey) {\n                        case 'top':\n                        case 'left':\n                            selectionBounds[rectKey] = Math.min(selectionBounds[rectKey], rangeRect[rectKey]);\n                            break;\n                        case 'bottom':\n                        case 'right':\n                        case 'height':\n                        case 'width':\n                            selectionBounds[rectKey] = Math.max(selectionBounds[rectKey], rangeRect[rectKey]);\n                            break;\n                        }\n                    }\n                });\n            };\n\n            const setInitialBoundary = function (rangeRect) {\n                if (rangeBoundingClientRect) {\n                    selectionBounds.initialLeft = rangeBoundingClientRect.left;\n                    selectionBounds.initialWidth = rangeBoundingClientRect.width;\n                } else if (rangeRect.top === selectionBounds.top) {\n                    if (selectionBounds.initialLeft === null) {\n                        selectionBounds.initialLeft = rangeRect.left;\n                    } else {\n                        selectionBounds.initialLeft = Math.min(rangeRect.left, selectionBounds.initialLeft);\n                    }\n\n                    if (selectionBounds.initialWidth === null) {\n                        selectionBounds.initialWidth = rangeRect.width;\n                    } else {\n                        selectionBounds.initialWidth = Math.max(rangeRect.right - selectionBounds.initialLeft, selectionBounds.initialWidth);\n                    }\n                }\n            };\n\n            for (let i = 0; i < rangeRects.length; i++) {\n                setSelectionBoundary(rangeRects[i], i);\n            }\n\n            for (let i = 0; i < rangeRects.length; i++) {\n                setInitialBoundary(rangeRects[i], i);\n            }\n\n            return selectionBounds;\n        },\n\n        collapseToStart () {\n            const currentRange = this.getCurrentRange();\n            const newRange = document.createRange();\n\n            newRange.setStart(currentRange.startContainer, currentRange.startOffset);\n            newRange.setEnd(currentRange.startContainer, currentRange.startOffset);\n\n            this.updateRange(newRange);\n        },\n\n        collapseToEnd () {\n            const currentSelection = this.getCurrentSelection();\n            currentSelection.collapseToEnd();\n        },\n\n        reSelect () {\n            const { props } = this;\n            if (props.cachedRange) {\n                this.updateRange(props.cachedRange, { silent: true });\n            }\n        },\n\n        selectAll (opts={}) {\n            const { dom, props } = this;\n            const { contextDocument } = props;\n            const range = contextDocument.createRange();\n            const rootElem = dom.el[0];\n\n            if (opts.selector) {\n                const elems = contextDocument.querySelectorAll(opts.selector);\n                range.setStartBefore(elems[0]);\n                range.setEndAfter(elems[elems.lenght - 1]);\n            } else {\n                range.setStart(rootElem, 0);\n                range.setEndAfter(rootElem.lastChild);\n            }\n\n            this.updateRange(range);\n        },\n\n        selectByCoordinates (rangeCoordinates) {\n            const { dom, props } = this;\n            const { contextDocument } = props;\n            const newRange = contextDocument.createRange();\n            const startCoordinates = rangeCoordinates.startCoordinates.slice(0);\n            const endCoordinates = rangeCoordinates.endCoordinates.slice(0);\n            const startOffset = startCoordinates.pop();\n            const endOffset = endCoordinates.pop();\n\n            let startContainer = dom.el[0];\n            let endContainer = dom.el[0];\n\n            while (startCoordinates.length) {\n                let startIndex = startCoordinates.shift();\n                startContainer = startContainer.childNodes[startIndex];\n            }\n\n            while (endCoordinates.length) {\n                let endIndex = endCoordinates.shift();\n                endContainer = endContainer.childNodes[endIndex];\n            }\n\n            newRange.setStart(startContainer, startOffset);\n            newRange.setEnd(endContainer, endOffset);\n\n            this.updateRange(newRange);\n        },\n\n        ensureTextOnlySelection () {\n            const { contextDocument } = this.props;\n            const currentRange = this.getCurrentRange();\n            const currentSelection = this.getCurrentSelection();\n            const {\n                startContainer,\n                endContainer,\n                commonAncestorContainer\n            } = currentRange;\n\n            if (\n                currentSelection.isCollapsed ||\n                (\n                    startContainer.nodeType === Node.TEXT_NODE &&\n                    endContainer.nodeType === Node.TEXT_NODE\n                )\n            ) {\n                return;\n            }\n\n            const rangeString = currentRange.toString();\n\n            let newRange = contextDocument.createRange();\n\n            const walker = contextDocument.createTreeWalker(\n                commonAncestorContainer,\n                NodeFilter.SHOW_TEXT,\n                null,\n                false\n            );\n\n            let textNodes = [];\n            while (walker.nextNode()) {\n                textNodes.push(walker.currentNode);\n            }\n\n            const firstTextNode = textNodes[0];\n            const lastTextNode = textNodes[textNodes.length - 1];\n\n            newRange.setStart(firstTextNode, 0);\n            newRange.setEnd(lastTextNode, lastTextNode.textContent.length);\n\n            let currentNodeIndex = 0;\n            let newStartOffset = 0;\n            let currentTextNode = textNodes[currentNodeIndex];\n\n            while (newRange.compareBoundaryPoints(Range.START_TO_START, currentRange) < 0) {\n                newStartOffset += 1;\n\n                if (newStartOffset > currentTextNode.textContent.length) {\n                    currentNodeIndex += 1;\n                    newStartOffset = 0;\n\n                    if (currentNodeIndex >= textNodes.length) {\n                        break;\n                    }\n                    currentTextNode = textNodes[currentNodeIndex];\n                }\n\n                newRange.setStart(currentTextNode, newStartOffset);\n            }\n\n            let newEndOffset = newStartOffset;\n            newRange.setEnd(currentTextNode, newEndOffset);\n\n            while (newRange.compareBoundaryPoints(Range.END_TO_END, currentRange) < 0) {\n                newEndOffset += 1;\n                if (newEndOffset > currentTextNode.textContent.length) {\n                    currentNodeIndex += 1;\n                    newEndOffset = 0;\n\n                    if (currentNodeIndex >= textNodes.length) {\n                        break;\n                    }\n                    currentTextNode = textNodes[currentNodeIndex];\n                }\n\n                newRange.setEnd(currentTextNode, newEndOffset);\n            }\n\n            if (newRange.toString() === rangeString) {\n                this.updateRange(newRange, { silent: true });\n            }\n        }\n    },\n\n    spansMultipleBlocks () {\n        const {\n            anchorNode,\n            focusNode\n        } = this.getCurrentSelection();\n\n        const rootElem = this.getRootElement();\n        const blockTagNames = toolbarConfig.getBlockTags();\n\n        const anchorBlock = DOM.getClosestInArray(anchorNode, blockTagNames, rootElem);\n        const focusBlock = DOM.getClosestInArray(focusNode, blockTagNames, rootElem);\n\n        return anchorBlock !== focusBlock;\n    }\n});\n\nexport default Selection;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/Selection.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 95,
    "kind": "variable",
    "name": "Selection",
    "memberof": "scripts/modules/Selection.js",
    "static": true,
    "longname": "scripts/modules/Selection.js~Selection",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/Selection.js",
    "importStyle": "Selection",
    "description": "",
    "lineNumber": 12,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "file",
    "name": "scripts/modules/TextFormatter.js",
    "content": "// jshint strict: false\n\nimport Module from '../core/Module';\nimport commands from '../utils/commands';\n\n/**\n* @access protected\n*/\nconst TextFormatter = Module({\n    name: 'TextFormatter',\n    props: {\n        cachedRange: null\n    },\n    handlers: {\n        requests: {},\n        commands: {\n            'format:text' : 'formatText'\n        },\n        events: {}\n    },\n    methods: {\n        formatText (opts) {\n            this.preProcess();\n            this.process(opts);\n            this.postProcess();\n        },\n\n        preProcess () {\n            const { mediator } = this;\n            mediator.exec('contenteditable:refocus');\n            mediator.exec('selection:reselect');\n        },\n\n        process (opts) {\n            commands.exec(opts.style, null);\n        },\n\n        postProcess () {\n            const { mediator } = this;\n\n            mediator.exec('contenteditable:refocus');\n            // mediator.exec('selection:reselect');\n        }\n    }\n});\n\nexport default TextFormatter;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/TextFormatter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 97,
    "kind": "variable",
    "name": "TextFormatter",
    "memberof": "scripts/modules/TextFormatter.js",
    "static": true,
    "longname": "scripts/modules/TextFormatter.js~TextFormatter",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/TextFormatter.js",
    "importStyle": "TextFormatter",
    "description": "",
    "lineNumber": 9,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "file",
    "name": "scripts/modules/Toolbar.js",
    "content": "// jshint strict: false\nimport Module from '../core/Module';\nimport DOM from '../utils/DOM';\nimport toolbarConfig from '../config/toolbar';\n\nimport toolbarTemplate from '../../templates/toolbar.html';\nimport toolbarStyles from '../../styles/toolbar.scss';\n\n/**\n* @access protected\n*/\nconst Toolbar = Module({\n    name: 'Toolbar',\n    dom: {\n        'toolbarMenuItems': '.typester-menu-item'\n    },\n    props: {\n        el: null,\n        styles: null,\n        mouseover: 0,\n        classNames: {\n            MENU_ITEM: 'typester-menu-item',\n            ACTIVE: 's--active'\n        }\n    },\n    handlers: {\n        commands: {\n            'toolbar:hide' : 'hideToolbar',\n            'toolbar:set:buttons' : 'setButtons'\n        },\n        events: {\n            // 'contenteditable:focus': 'showToolbar',\n            'app:destroy' : 'destroy',\n            'selection:update' : 'handleSelectionChange',\n            // 'selection:start' : 'handleSelectStart',\n            'selection:change' : 'handleSelectionChange',\n            'mouse:down': 'handleMouseDown',\n            'mouse:up': 'handleMouseUp',\n            'import:from:canvas:complete' : 'handleCanvasImport'\n        },\n        domEvents: {\n            'click' : 'handleToolbarClick',\n            'mouseover' : 'handleMouseOver',\n            'mouseout' : 'handleMouseOut'\n        }\n    },\n    methods: {\n        setup () {\n            this.appendStyles();\n            this.render();\n        },\n\n        init () {\n            this.updateToolbarState();\n        },\n\n        appendStyles () {\n            const { props } = this;\n            props.styles = DOM.addStyles(toolbarStyles);\n        },\n\n        render () {\n            const { mediator, props } = this;\n            const buttonConfigs = this.getButtonConfigs();\n            const wrapperEl = document.createElement('div');\n\n            let toolbarHTML = toolbarTemplate(buttonConfigs);\n\n            if (typeof toolbarHTML === 'string') {\n                wrapperEl.innerHTML = toolbarHTML;\n            } else {\n                wrapperEl.appendChild(toolbarHTML[0]);\n            }\n\n            const toolbarEl = wrapperEl.childNodes[0];\n            props.flyout = props.flyout || mediator.get('flyout:new');\n            props.flyout.clearContent();\n            props.flyout.show();\n            props.flyout.appendContent(wrapperEl.childNodes[0]);\n\n            return toolbarEl;\n        },\n\n        getButtonConfigs () {\n            const { mediator } = this;\n            const contentEditableButtons = mediator.get('contenteditable:toolbar:buttons') || [];\n            const configButtons = contentEditableButtons.length ? contentEditableButtons : toolbarConfig.buttons;\n\n            let buttons = [];\n\n            configButtons.forEach((configKey) => {\n                // NB This needs to be looked at\n                if (configKey === 'anchor') {\n                    configKey = 'link';\n                }\n                const buttonConfig = Object.assign({ configKey }, toolbarConfig.buttonConfigs[configKey]);\n                buttons.push(buttonConfig);\n            });\n\n            return { buttons };\n        },\n\n        handleToolbarClick (evnt) {\n            const { mediator, props } = this;\n            mediator.exec('contenteditable:refocus');\n            mediator.exec('selection:reselect');\n\n            const menuItemEl = DOM.getClosest(evnt.target, `.${props.classNames.MENU_ITEM}`);\n            const { dataset } = menuItemEl;\n            const { configKey } = dataset;\n            const buttonConfig = toolbarConfig.buttonConfigs[configKey];\n            const { formatter, opts } = buttonConfig;\n            const toolbarMenuItemState = this.getMenuItemState(menuItemEl);\n\n            opts.toggle = buttonConfig.toggles && toolbarMenuItemState.isActive;\n            mediator.exec(`format:${formatter}`, opts);\n        },\n\n        // handleSelectStart () {\n        //     this.hideToolbar();\n        // },\n\n        handleSelectionChange () {\n            const { props } = this;\n            if (props.selectionChangeTimeout) {\n                clearTimeout(props.selectionChangeTimeout);\n            }\n            props.selectionChangeTimeout = setTimeout(() => {\n                this.updateToolbarState();\n            }, 10);\n        },\n\n        handleMouseDown () {\n            this.updateToolbarState();\n        },\n\n        handleMouseUp () {\n            this.updateToolbarState();\n        },\n\n        handleMouseOver () {\n            const { props } = this;\n            props.mouseover += 1;\n            props.mouseover = Math.min(1, props.mouseover);\n        },\n\n        handleMouseOut () {\n            const { props } = this;\n            props.mouseover -= 1;\n            props.mouseover = Math.max(0, props.mouseover);\n        },\n\n        handleCanvasImport () {\n            this.updateToolbarState();\n        },\n\n        hideToolbar () {\n            const { props } = this;\n            props.flyout.hide();\n        },\n\n        showToolbar () {\n            this.render();\n        },\n\n        positionToolbar () {\n            const { mediator, props } = this;\n            const selectionBounds = mediator.get('selection:bounds');\n\n            if (selectionBounds.initialWidth > 0) {\n                const scrollOffset = DOM.getScrollOffset();\n                const docRelTop = selectionBounds.top + scrollOffset.y;\n                const docRelLeft = selectionBounds.initialLeft + scrollOffset.x;\n                const docRelCenter = selectionBounds.initialWidth / 2 + docRelLeft;\n\n                props.flyout.position({\n                    left: docRelCenter + 'px',\n                    top: docRelTop + 'px'\n                });\n            }\n        },\n\n        updateToolbarState () {\n            const { mediator, props } = this;\n            const currentSelection = mediator.get('selection:current');\n            const linkFormatterActive = mediator.get('format:link:active');\n            const mouseIsDown = mediator.get('mouse:is:down');\n\n            if (\n                !currentSelection ||\n                currentSelection.isCollapsed ||\n                !currentSelection.toString().trim().length ||\n                linkFormatterActive ||\n                !document.activeElement.hasAttribute('contenteditable') ||\n                mouseIsDown\n            ) {\n                if (props.mouseover) {\n                    return;\n                }\n                this.hideToolbar();\n            } else {\n                this.positionToolbar();\n                this.showToolbar();\n                this.updateMenuItems();\n            }\n        },\n\n        updateMenuItems () {\n            const { dom, mediator } = this;\n            mediator.exec('selection:ensure:text:only');\n            for (let i = 0; i < dom.toolbarMenuItems.length; i++) {\n                let toolbarMenuItem = dom.toolbarMenuItems[i];\n                this.updateMenuItemState(toolbarMenuItem);\n            }\n        },\n\n        updateMenuItemState (toolbarMenuItem) {\n            const { props } = this;\n            const toolbarMenuItemState = this.getMenuItemState(toolbarMenuItem);\n\n            if (toolbarMenuItemState.isDisabled) {\n                toolbarMenuItem.setAttribute('disabled', '');\n            } else {\n                toolbarMenuItem.removeAttribute('disabled');\n            }\n\n            DOM.toggleClass(toolbarMenuItem, props.classNames.ACTIVE, toolbarMenuItemState.isActive);\n        },\n\n        getMenuItemState (toolbarMenuItem) {\n            const { mediator } = this;\n            const { configKey } = toolbarMenuItem.dataset;\n\n            const config = toolbarConfig.buttonConfigs[configKey];\n\n            const activeIn = config.activeIn || [];\n            const disabledIn = config.disabledIn || [];\n            const isActive = mediator.get('selection:in:or:contains', activeIn);\n\n            let isDisabled = false;\n            if (typeof disabledIn === 'function') {\n                isDisabled = disabledIn.call(config, mediator);\n            } else {\n                isDisabled = mediator.get('selection:in:or:contains', disabledIn);\n            }\n\n            return {\n                isActive,\n                isDisabled\n            };\n        },\n\n        destroy () {\n            const { props } = this;\n            props.flyout.remove();\n        }\n    }\n});\n\nexport default Toolbar;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/modules/Toolbar.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 99,
    "kind": "variable",
    "name": "Toolbar",
    "memberof": "scripts/modules/Toolbar.js",
    "static": true,
    "longname": "scripts/modules/Toolbar.js~Toolbar",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/modules/Toolbar.js",
    "importStyle": "Toolbar",
    "description": "",
    "lineNumber": 12,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "file",
    "name": "scripts/polyfills/array/forEach.js",
    "content": "// Production steps of ECMA-262, Edition 5, 15.4.4.18\n// Reference: http://es5.github.io/#x15.4.4.18\nif (!Array.prototype.forEach) {\n\n    Array.prototype.forEach = function(callback/*, thisArg*/) {\n\n        var T, k;\n\n        if (this == null) {\n            throw new TypeError('this is null or not defined');\n        }\n\n        // 1. Let O be the result of calling toObject() passing the\n        // |this| value as the argument.\n        var O = Object(this);\n\n        // 2. Let lenValue be the result of calling the Get() internal\n        // method of O with the argument \"length\".\n        // 3. Let len be toUint32(lenValue).\n        var len = O.length >>> 0;\n\n        // 4. If isCallable(callback) is false, throw a TypeError exception.\n        // See: http://es5.github.com/#x9.11\n        if (typeof callback !== 'function') {\n            throw new TypeError(callback + ' is not a function');\n        }\n\n        // 5. If thisArg was supplied, let T be thisArg; else let\n        // T be undefined.\n        if (arguments.length > 1) {\n            T = arguments[1];\n        }\n\n        // 6. Let k be 0\n        k = 0;\n\n        // 7. Repeat, while k < len\n        while (k < len) {\n\n            var kValue;\n\n            // a. Let Pk be ToString(k).\n            //    This is implicit for LHS operands of the in operator\n            // b. Let kPresent be the result of calling the HasProperty\n            //    internal method of O with argument Pk.\n            //    This step can be combined with c\n            // c. If kPresent is true, then\n            if (k in O) {\n\n                // i. Let kValue be the result of calling the Get internal\n                // method of O with argument Pk.\n                kValue = O[k];\n\n                // ii. Call the Call internal method of callback with T as\n                // the this value and argument list containing kValue, k, and O.\n                callback.call(T, kValue, k, O);\n            }\n            // d. Increase k by 1.\n            k++;\n        }\n        // 8. return undefined\n    };\n}\n\nif (window.NodeList && !NodeList.prototype.forEach) {\n    NodeList.prototype.forEach = function (callback, thisArg) {\n        thisArg = thisArg || window;\n        for (var i = 0; i < this.length; i++) {\n            callback.call(thisArg, this[i], i, this);\n        }\n    };\n}\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/polyfills/array/forEach.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 101,
    "kind": "file",
    "name": "scripts/polyfills/index.js",
    "content": "import './array/forEach';\nimport './object/assign';\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/polyfills/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 102,
    "kind": "file",
    "name": "scripts/polyfills/object/assign.js",
    "content": "if (typeof Object.assign !== 'function') {\n    Object.assign = function (target) { // .length of function is 2\n        'use strict';\n        var to, index, nextSource, nextKey;\n\n        if (target === null) { // TypeError if undefined or null\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        to = Object(target);\n\n        for (index = 1; index < arguments.length; index++) {\n            nextSource = arguments[index];\n\n            if (nextSource !== null) { // Skip over if undefined or null\n                for (nextKey in nextSource) {\n                    // Avoid bugs when hasOwnProperty is shadowed\n                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                        to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n        return to;\n    };\n}\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/polyfills/object/assign.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 103,
    "kind": "file",
    "name": "scripts/utils/DOM.js",
    "content": "// jshint strict: false\n/* eslint-disable no-alert, no-console */\n\nimport browser from './browser';\n\n/**\n* @access protected\n*/\nconst DOM = {\n    regex: {\n        getById: /^#/,\n        getByClassName: /^\\./,\n        getByTag: /^[a-z]/\n    },\n\n    getElements (elementsObj, rootEl) {\n        for (let elementKey in elementsObj) {\n            if (elementsObj.hasOwnProperty(elementKey) && elementKey !== 'rootEl') {\n                let elementObj = elementsObj[elementKey];\n                let { selector } = elementObj;\n\n                rootEl = elementObj.rootEl || rootEl;\n                rootEl = typeof rootEl === 'function' ? rootEl() : rootEl;\n\n                elementObj.el = DOM.get(selector, rootEl);\n            }\n        }\n    },\n\n    // Public methods\n    get(selector, domRoot = document) {\n        if (DOM.isElement(selector)) {\n            return [selector];\n        }\n        const getMethodName = DOM._getGetMethodName(selector);\n        return DOM[getMethodName](selector, domRoot);\n    },\n\n    getByClassName(className, domRoot = document) {\n        className = DOM._cleanSelector(className);\n        return domRoot.getElementsByClassName(className);\n    },\n\n    getByTag(tag, domRoot = document) {\n        tag = DOM._cleanSelector(tag);\n        return domRoot.getElementsByTagName(tag);\n    },\n\n    getById(id) {\n        return document.getElementById(id);\n    },\n\n    getClosest(node, selector, ceilNode) {\n        const rootEl = ceilNode || DOM.getRootEl();\n        const checkType = /^\\[/.test(selector) ? 'attribute' :\n                          /^\\./.test(selector) ? 'class' :\n                          /^\\#/.test(selector) ? 'id' :\n                          'tag';\n\n        let returnNode = false;\n        let attrName, className, idStr, parentId;\n\n        if (node === rootEl) {\n            return null;\n        }\n\n        while (node.nodeType !== Node.ELEMENT_NODE) {\n            node = node.parentNode;\n        }\n\n        switch (checkType) {\n        case 'attribute':\n            attrName = selector.match(/\\[(.*?)\\]/)[1];\n            returnNode = node.hasAttribute(attrName);\n            break;\n        case 'class':\n            className = selector.replace('.', '');\n            returnNode = node.classList && node.classList.contains(className);\n            break;\n        case 'id':\n            idStr = selector.replace('#', '');\n            parentId = node.getAttribute('id');\n            returnNode = idStr === parentId;\n            break;\n        case 'tag':\n            returnNode = node.nodeName.toLowerCase() === selector.toLowerCase();\n            break;\n        }\n\n        if (returnNode) {\n            return node;\n        } else {\n            return DOM.getClosest(node.parentNode, selector, rootEl);\n        }\n    },\n\n    getClosestInArray (node, nameArray, ceilNode) {\n        let parentNode = node;\n\n        while (nameArray.indexOf(parentNode.nodeName) < 0 && parentNode !== ceilNode) {\n            parentNode = parentNode.parentNode;\n        }\n\n        if (parentNode !== ceilNode) {\n            return parentNode;\n        } else {\n            return null;\n        }\n    },\n\n    getFurthest (node, selector) {\n        const rootEl = DOM.getRootEl();\n        let currentNode = node;\n        let furthest = null;\n\n        selector = selector instanceof Array ? selector : [selector];\n\n        while (currentNode && currentNode !== rootEl) {\n            if (selector.indexOf(currentNode.nodeName) > -1) {\n                furthest = currentNode;\n            }\n            currentNode = currentNode.parentNode || currentNode.parentElement;\n        }\n\n        return furthest;\n    },\n\n    nextNode (node) {\n        if (node.hasChildNodes()) {\n            return node.firstChild;\n        } else {\n            while (node && !node.nextSibling) {\n                node = node.parentNode;\n            }\n            if (!node) {\n                return null;\n            }\n            return node.nextSibling;\n        }\n    },\n\n    appendTo(selector, tag) {\n        const htmlNode = DOM.isElement(tag) ? tag : document.createElement(tag);\n        const targetEl = DOM.get(selector);\n\n        for (let i = 0; i < targetEl.length; i++) {\n            targetEl[i].appendChild(htmlNode);\n        }\n\n        return htmlNode;\n    },\n\n    addStyles(styles) {\n        const styleEl = DOM.appendTo('head', 'style');\n\n        styleEl.setAttribute('id', 'typester-styles');\n        styleEl.setAttribute('type', 'text/css');\n\n        if (styleEl.styleSheet) {\n            styleEl.styleSheet.cssText = styles;\n        } else {\n            styleEl.appendChild(document.createTextNode(styles));\n        }\n\n        return styleEl;\n    },\n\n    // From http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n    isNode(o) {\n        return (\n            typeof Node === 'object' ? o instanceof Node :\n            o && typeof o === 'object' && typeof o.nodeType === 'number' && typeof o.nodeName === 'string'\n        );\n    },\n\n    isElement(elem) {\n        let isElement = false;\n\n        isElement = elem instanceof Window || elem instanceof Document;\n        isElement = isElement || typeof HTMLElement === 'object' && elem instanceof HTMLElement;\n        isElement = isElement || elem && typeof elem === 'object' && elem !== null && elem.nodeType === 1 && typeof elem.nodeName === 'string';\n\n        return isElement;\n    },\n\n    isIn(node, nodeName, ceilNode) {\n        let isIn = false;\n        let currentNode = node;\n        let nameArray = nodeName instanceof Array ? nodeName : nodeName.split('/');\n\n        ceilNode = ceilNode || DOM.getRootEl();\n        nameArray = nameArray.map((name) => {\n            return name.toLowerCase();\n        });\n\n        while (!isIn && currentNode !== ceilNode) {\n            isIn = nameArray.indexOf(currentNode.nodeName.toLowerCase()) > -1;\n            currentNode = currentNode.parentNode;\n        }\n\n        return isIn;\n    },\n\n    isChildOf(childNode, parentNode) {\n        if (childNode instanceof Array) {\n            childNode = childNode[0];\n        }\n\n        if (parentNode instanceof Array) {\n            parentNode = parentNode[0];\n        }\n\n        return parentNode && childNode && parentNode.contains(childNode);\n    },\n\n    addClass(el, classStr) {\n        el.classList.add(classStr);\n    },\n\n    toggleClass(el, classStr, force) {\n        let addClass = force !== undefined ? force : !el.classList.contains(classStr);\n\n        if (addClass) {\n            DOM.addClass(el, classStr);\n        } else {\n            DOM.removeClass(el, classStr);\n        }\n    },\n\n    removeClass(el, classStr) {\n        el.classList.remove(classStr);\n    },\n\n    isBlock(node) {\n        return DOM.getStyle(node, 'display') === 'block';\n    },\n\n    closestElement(node) {\n        let returnNode = node;\n\n        while (returnNode.nodeType !== 1) {\n            returnNode = returnNode.parentNode;\n        }\n\n        return returnNode;\n    },\n\n    getStyles(node) {\n        const closestElement = DOM.closestElement(node);\n        const gcs = 'getComputedStyle' in window;\n        return (gcs ? window.getComputedStyle(closestElement) : closestElement.currentStyle);\n    },\n\n    getStyle(node, property) {\n        const nodeStyles = DOM.getStyles(node);\n        return nodeStyles[property];\n    },\n\n    insertBefore (newNode, referenceNode) {\n        const parentNode = referenceNode.parentNode;\n        parentNode.insertBefore(newNode, referenceNode);\n    },\n\n    insertAfter(newNode, referenceNode) {\n        const parentNode = referenceNode.parentNode;\n\n        if (parentNode.lastChild === referenceNode) {\n            parentNode.appendChild(newNode);\n        } else {\n            parentNode.insertBefore(newNode, referenceNode.nextSibling);\n        }\n    },\n\n    isLastChild (node) {\n        return node === node.parentNode.lastChild;\n    },\n\n    isFirstChild (node) {\n        return node === node.parentNode.firstChild;\n    },\n\n    wrapRange (nodeName, nodeOpts) {\n        const sel = window.getSelection();\n        const range = sel.getRangeAt(0);\n        const wrapper = document.createElement(nodeName);\n\n        for (let optKey in nodeOpts) {\n            if (nodeOpts.hasOwnProperty(optKey)) {\n                wrapper[optKey] = nodeOpts[optKey];\n            }\n        }\n\n        range.surroundContents(wrapper);\n\n        return wrapper;\n    },\n\n    unwrap(node, opts={}) {\n        const unwrappedNodes = [];\n\n        if (node.childNodes) {\n            while (node.firstChild) {\n                unwrappedNodes.push(node.firstChild);\n                DOM.insertBefore(node.firstChild, node);\n            }\n        }\n\n        if (!opts.keepNode) {\n            DOM.removeNode(node);\n        }\n        return unwrappedNodes;\n    },\n\n    unwrapFrom (node, wrappers) {\n        const rootEl = DOM.getRootEl();\n        let currentNode = node;\n        let unwrappedNodes = [currentNode];\n\n        while (currentNode !== rootEl) {\n            let parentNode = currentNode.parentNode || currentNode.parentElement;\n\n            if (wrappers.indexOf(currentNode.nodeName) > -1) {\n                unwrappedNodes = DOM.unwrap(currentNode);\n            }\n\n            currentNode = parentNode;\n        }\n\n        return unwrappedNodes;\n    },\n\n    unwrapToRoot (node) {\n        const rootEl = DOM.getRootEl();\n        let currentNode = node.parentNode;\n\n        while (currentNode !== rootEl) {\n            let parentNode = currentNode.parentNode;\n            DOM.unwrap(currentNode);\n            currentNode = parentNode;\n        }\n    },\n\n    removeNode (node) {\n        const parentNode = node.parentElement || node.parentNode;\n        if (parentNode) {\n            parentNode.removeChild(node);\n        }\n    },\n\n    replaceNode (node, newNode) {\n        const parentNode = node.parentNode || node.parentElement;\n        if (parentNode) {\n            parentNode.replaceChild(newNode, node);\n        }\n    },\n\n    getContainerZIndex (node) {\n        let container = node;\n        let topMostContainerZIndex = 0;\n\n        while (container && container !== document.body) {\n            let containerZIndex = window.getComputedStyle(container).zIndex;\n            if (/^[0-9]+$/.test(containerZIndex)) {\n                topMostContainerZIndex = parseInt(containerZIndex);\n            }\n            container = container.parentNode;\n        }\n\n        return topMostContainerZIndex;\n    },\n\n    // // From http://stackoverflow.com/questions/6139107/programmatically-select-text-in-a-contenteditable-html-element\n    // selectNodeContents(node) {\n    //     node = node || DOM.getAnchorNode();\n    //     if (!node) {\n    //         return;\n    //     }\n    //\n    //     const nodes = node instanceof Array ? node : [node];\n    //     const startNode = nodes[0];\n    //     const endNode = nodes[nodes.length - 1];\n    //\n    //     const range = document.createRange();\n    //     range.setStart(startNode, 0);\n    //     range.setEnd(endNode, endNode.length);\n    //\n    //     const sel = window.getSelection();\n    //     if (sel.rangeCount > 0) {\n    //         sel.removeAllRanges();\n    //     }\n    //     sel.addRange(range);\n    // },\n\n    getRootEl() {\n        const selection = document.getSelection();\n        const anchorNode = selection.anchorNode;\n\n        let rootEl = anchorNode;\n        while (rootEl && !(rootEl.nodeType === Node.ELEMENT_NODE && rootEl.hasAttribute('contenteditable'))) {\n            rootEl = rootEl.parentNode;\n        }\n\n        return rootEl;\n    },\n\n    removeInvalidTagsUpward (node, acceptedTags) {\n        const rootEl = DOM.getRootEl();\n        let currentNode = node;\n        let invalidTags = [];\n        let unwrappedNodes = [node];\n\n        while (currentNode !== rootEl) {\n            if (currentNode.nodeType === 1 && acceptedTags.indexOf(currentNode.nodeName) < 0) {\n                invalidTags.push(currentNode);\n            }\n            currentNode = currentNode.parentNode || currentNode.parentElement;\n        }\n\n        for (let i = 0; i < invalidTags.length; i++) {\n            let invalidTag = invalidTags[i];\n            unwrappedNodes = DOM.unwrap(invalidTag);\n        }\n\n        return unwrappedNodes;\n    },\n\n    // From: http://stackoverflow.com/questions/37025488/remove-whitespace-from-window-selection-in-js\n    trimSelection (opts) {\n        opts = opts || { fromEnd: true };\n\n        const sel = window.getSelection();\n        const range = sel.getRangeAt(0);\n        const selStr = sel.toString();\n\n        let regEx, container, method, regExResult,\n            offset = range.startOffset, rangeClone;\n\n        if (opts.bothEnds) {\n            opts.fromEnd = true;\n        }\n\n        if (opts.fromEnd) {\n            regEx = /\\s+$/;\n            container = range.endContainer;\n            method = range.setEnd;\n        } else if (opts.fromStart) {\n            regEx = /[^\\s]/;\n            container = range.startContainer;\n            method = range.setStart;\n        }\n\n\n        regExResult = regEx.exec(selStr);\n        if (regExResult && regExResult.index > 0) {\n            if (opts.fromEnd && offset + regExResult.index > container.length) {\n                regExResult = regEx.exec(container.textContent);\n                if (regExResult) {\n                    method.call(range, container, regExResult.index);\n                }\n            } else {\n                method.call(range, container, offset + regExResult.index);\n            }\n\n            rangeClone = range.cloneRange();\n            sel.removeAllRanges();\n            sel.addRange(rangeClone);\n        }\n\n        if (opts.bothEnds) {\n            if (opts.fromEnd) {\n                DOM.trimSelection({ fromStart: true });\n            } else {\n                DOM.trimSelection({ fromEnd: true });\n            }\n        }\n    },\n\n    createPseudoSelect () {\n        const rootEl = DOM.getRootEl();\n        const wrapper = DOM.wrapRange('SPAN', {\n            className: 'pseudo-selection'\n        });\n        let selectionStyles;\n\n        if (browser.isFirefox()) {\n            selectionStyles = window.getComputedStyle(rootEl, '::-moz-selection');\n        } else {\n            selectionStyles = window.getComputedStyle(rootEl, '::selection');\n        }\n\n        wrapper.style['background-color'] = selectionStyles['background-color'];\n        if (wrapper.style['background-color'] === 'transparent') {\n            wrapper.style['background-color'] = '#EEEEEE';\n        }\n        wrapper.style.color = selectionStyles.color;\n\n        return wrapper;\n    },\n\n    // From: https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY\n    getScrollOffset () {\n        const supportPageOffset = window.pageXOffset !== undefined;\n        const isCSS1Compat = ((document.compatMode || '') === 'CSS1Compat');\n\n        const x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;\n        const y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;\n\n        return {x, y};\n    },\n\n    childIndex (node) {\n        let child = node;\n        let childIndex = 0;\n\n        while ((child = child.previousSibling) !== null) {\n            childIndex++;\n        }\n\n        return childIndex;\n    },\n\n    //Pseudo-private methods\n    _getGetMethodName(selector) {\n        let methodName = null;\n\n        Object.keys(DOM.regex).forEach((regexKey) => {\n            const regex = DOM.regex[regexKey];\n            if (regex.test(selector)) {\n                methodName = regexKey;\n            }\n        });\n\n        return methodName;\n    },\n\n    _cleanSelector(selector) {\n        return selector.replace(/^[\\.#]/, '');\n    },\n\n    _createEl(tag) {\n        return document.createElement(tag);\n    }\n};\n\nexport default DOM;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/utils/DOM.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 104,
    "kind": "variable",
    "name": "DOM",
    "memberof": "scripts/utils/DOM.js",
    "static": true,
    "longname": "scripts/utils/DOM.js~DOM",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/utils/DOM.js",
    "importStyle": "DOM",
    "description": "",
    "lineNumber": 9,
    "type": {
      "types": [
        "{\"regex\": *, \"getElements\": function, \"get\": function, \"getByClassName\": function, \"getByTag\": function, \"getById\": function, \"getClosest\": function, \"getClosestInArray\": function, \"getFurthest\": function, \"nextNode\": function, \"appendTo\": function, \"addStyles\": function, \"isNode\": function, \"isElement\": function, \"isIn\": function, \"isChildOf\": function, \"addClass\": function, \"toggleClass\": function, \"removeClass\": function, \"isBlock\": function, \"closestElement\": function, \"getStyles\": function, \"getStyle\": function, \"insertBefore\": function, \"insertAfter\": function, \"isLastChild\": function, \"isFirstChild\": function, \"wrapRange\": function, \"unwrap\": function, \"unwrapFrom\": function, \"unwrapToRoot\": function, \"removeNode\": function, \"replaceNode\": function, \"getContainerZIndex\": function, \"getRootEl\": function, \"removeInvalidTagsUpward\": function, \"trimSelection\": function, \"createPseudoSelect\": function, \"getScrollOffset\": function, \"childIndex\": function, \"_getGetMethodName\": function, \"_cleanSelector\": function, \"_createEl\": function}"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "file",
    "name": "scripts/utils/browser.js",
    "content": "// jshint strict: false\n\n/**\n* @access protected\n*/\nconst browser = {\n    // From https://codepen.io/gapcode/pen/vEJNZN\n    ieVersion () {\n        const ua = window.navigator.userAgent;\n\n        const msie = ua.indexOf('MSIE ');\n        if (msie > 0) {\n            // IE 10 or older => return version number\n            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n        }\n\n        const trident = ua.indexOf('Trident/');\n        if (trident > 0) {\n            // IE 11 => return version number\n            const rv = ua.indexOf('rv:');\n            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n        }\n\n        const edge = ua.indexOf('Edge/');\n        if (edge > 0) {\n            // Edge (IE 12+) => return version number\n            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n        }\n\n        // other browser\n        return false;\n    },\n\n    isIE () {\n        const ieVersion = browser.ieVersion();\n        return ieVersion && ieVersion < 12;\n    },\n\n    isFirefox () {\n        return window.navigator.userAgent.indexOf('Firefox') > -1;\n    }\n};\n\nexport default browser;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/utils/browser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 106,
    "kind": "variable",
    "name": "browser",
    "memberof": "scripts/utils/browser.js",
    "static": true,
    "longname": "scripts/utils/browser.js~browser",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/utils/browser.js",
    "importStyle": "browser",
    "description": "",
    "lineNumber": 6,
    "type": {
      "types": [
        "{\"ieVersion\": function, \"isIE\": function, \"isFirefox\": function}"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "file",
    "name": "scripts/utils/commands.js",
    "content": "// jshint strict: false\nimport conf from '../config/config';\nimport browser from './browser';\n\n/**\n* @access protected\n*/\nconst commands = {\n    exec (command, value=null, contextDocument=document) {\n        if (command === 'formatBlock') {\n            value = commands.prepBlockValue(value);\n        }\n        contextDocument.execCommand(command, false, value);\n    },\n\n    formatBlock (style, contextDocument=document) {\n        commands.exec('formatBlock', style, contextDocument);\n    },\n\n    defaultBlockFormat (contextDocument=document) {\n        commands.formatBlock(conf.defaultBlock, contextDocument);\n    },\n\n    prepBlockValue (value) {\n        const ieVersion = browser.ieVersion();\n        value = value.toUpperCase();\n        return ieVersion && ieVersion < 12 ? `<${value}>` : value;\n    }\n};\n\nexport default commands;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/utils/commands.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 108,
    "kind": "variable",
    "name": "commands",
    "memberof": "scripts/utils/commands.js",
    "static": true,
    "longname": "scripts/utils/commands.js~commands",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/utils/commands.js",
    "importStyle": "commands",
    "description": "",
    "lineNumber": 8,
    "type": {
      "types": [
        "{\"exec\": function, \"formatBlock\": function, \"defaultBlockFormat\": function, \"prepBlockValue\": function}"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "file",
    "name": "scripts/utils/func.js",
    "content": "// jshint strict: false\n\n/**\n* @access protected\n*/\nconst func = {\n    bind (func, context) {\n        return (...args) => {\n            return func.apply(context, args);\n        };\n    },\n\n    bindObj (funcObj, context) {\n        let boundFuncObj = {};\n\n        Object.keys(funcObj).forEach((funcKey) => {\n            boundFuncObj[funcKey] = func.bind(funcObj[funcKey], context);\n        });\n\n        return boundFuncObj;\n    }\n};\n\nexport default func;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/utils/func.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 110,
    "kind": "variable",
    "name": "func",
    "memberof": "scripts/utils/func.js",
    "static": true,
    "longname": "scripts/utils/func.js~func",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/utils/func.js",
    "importStyle": "func",
    "description": "",
    "lineNumber": 6,
    "type": {
      "types": [
        "{\"bind\": function, \"bindObj\": function}"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "file",
    "name": "scripts/utils/guid.js",
    "content": "// jshint strict: false\n\n/**\n* @access protected\n*/\nconst guid = function guid() {\n    function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000)\n        .toString(16)\n        .substring(1);\n    }\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n    s4() + '-' + s4() + s4() + s4();\n};\n\nexport default guid;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/utils/guid.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 112,
    "kind": "function",
    "name": "guid",
    "memberof": "scripts/utils/guid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "scripts/utils/guid.js~guid",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/utils/guid.js",
    "importStyle": "guid",
    "description": "",
    "lineNumber": 6,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "file",
    "name": "scripts/utils/keycodes.js",
    "content": "/**\n* @access protected\n*/\nconst keycodes = {\n    ENTER: 13,\n    BACKSPACE: 8,\n    TAB: 9\n};\n\nexport default keycodes;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/utils/keycodes.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 114,
    "kind": "variable",
    "name": "keycodes",
    "memberof": "scripts/utils/keycodes.js",
    "static": true,
    "longname": "scripts/utils/keycodes.js~keycodes",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/utils/keycodes.js",
    "importStyle": "keycodes",
    "description": "",
    "lineNumber": 4,
    "type": {
      "types": [
        "{\"ENTER\": number, \"BACKSPACE\": number, \"TAB\": number}"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "file",
    "name": "scripts/utils/paste.js",
    "content": "// jshint strict: false\n\n// Taken from medium editor: https://github.com/yabwe/medium-editor/blob/master/src/js/extensions/paste.js\n/**\n* @access protected\n*/\nconst pasteUtils = {\n    createReplacements () {\n        return [\n            // Remove anything but the contents within the BODY element\n            [new RegExp(/^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/g), ''],\n\n            // cleanup comments added by Chrome when pasting html\n            [new RegExp(/<!--StartFragment-->|<!--EndFragment-->/g), ''],\n\n            // Trailing BR elements\n            [new RegExp(/<br>$/i), ''],\n\n            // replace two bogus tags that begin pastes from google docs\n            [new RegExp(/<[^>]*docs-internal-guid[^>]*>/gi), ''],\n            [new RegExp(/<\\/b>(<br[^>]*>)?$/gi), ''],\n\n             // un-html spaces and newlines inserted by OS X\n            [new RegExp(/<span class=\"Apple-converted-space\">\\s+<\\/span>/g), ' '],\n            [new RegExp(/<br class=\"Apple-interchange-newline\">/g), '<br>'],\n\n            // replace google docs italics+bold with a span to be replaced once the html is inserted\n            [new RegExp(/<span[^>]*(font-style:italic;font-weight:(bold|700)|font-weight:(bold|700);font-style:italic)[^>]*>/gi), '<span class=\"replace-with italic bold\">'],\n\n            // replace google docs italics with a span to be replaced once the html is inserted\n            [new RegExp(/<span[^>]*font-style:italic[^>]*>/gi), '<span class=\"replace-with italic\">'],\n\n            //[replace google docs bolds with a span to be replaced once the html is inserted\n            [new RegExp(/<span[^>]*font-weight:(bold|700)[^>]*>/gi), '<span class=\"replace-with bold\">'],\n\n             // replace manually entered b/i/a tags with real ones\n            [new RegExp(/&lt;(\\/?)(i|b|a)&gt;/gi), '<$1$2>'],\n\n             // replace manually a tags with real ones, converting smart-quotes from google docs\n            [new RegExp(/&lt;a(?:(?!href).)+href=(?:&quot;|&rdquo;|&ldquo;|\"|“|”)(((?!&quot;|&rdquo;|&ldquo;|\"|“|”).)*)(?:&quot;|&rdquo;|&ldquo;|\"|“|”)(?:(?!&gt;).)*&gt;/gi), '<a href=\"$1\">'],\n\n            // Newlines between paragraphs in html have no syntactic value,\n            // but then have a tendency to accidentally become additional paragraphs down the line\n            [new RegExp(/<\\/p>\\n+/gi), '</p>'],\n            [new RegExp(/\\n+<p/gi), '<p'],\n\n            // Microsoft Word makes these odd tags, like <o:p></o:p>\n            [new RegExp(/<\\/?o:[a-z]*>/gi), ''],\n\n            // Microsoft Word adds some special elements around list items\n            [new RegExp(/<!\\[if !supportLists\\]>(((?!<!).)*)<!\\[endif]\\>/gi), '$1']\n        ];\n    }\n};\n\nexport default pasteUtils;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/utils/paste.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 116,
    "kind": "variable",
    "name": "pasteUtils",
    "memberof": "scripts/utils/paste.js",
    "static": true,
    "longname": "scripts/utils/paste.js~pasteUtils",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/utils/paste.js",
    "importStyle": "pasteUtils",
    "description": "",
    "lineNumber": 7,
    "type": {
      "types": [
        "{\"createReplacements\": function}"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "file",
    "name": "scripts/utils/string.js",
    "content": "// jshint strict: false\n\n/**\n* @access protected\n*/\nexport default {\n    capitalize (string) {\n        return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n};\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/utils/string.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 118,
    "kind": "file",
    "name": "scripts/utils/zeroWidthSpace.js",
    "content": "// jshint strict: false\n/**\n* @access protected\n*/\nconst zeroWidthSpaceEntity = '&ZeroWidthSpace;';\n\n/**\n* @access protected\n*/\nconst zeroWidthSpace = {\n    generate () {\n        let tmpEl = document.createElement('span');\n        tmpEl.innerHTML = zeroWidthSpaceEntity;\n        return tmpEl;\n    },\n\n    get () {\n        const tmpEl = zeroWidthSpace.generate();\n        return tmpEl.firstChild;\n    },\n\n    assert (node) {\n        const tmpEl = zeroWidthSpace.generate();\n        if (node.nodeType === Node.ELEMENT_NODE) {\n            return node.innerHTML === tmpEl.innerHTML;\n        } else if (node.nodeType === Node.TEXT_NODE) {\n            return node.nodeValue === tmpEl.firstChild.nodeValue;\n        }\n    }\n};\n\nexport default zeroWidthSpace;\n",
    "static": true,
    "longname": "/home/fred/Development/TypeCode/typester/src/scripts/utils/zeroWidthSpace.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 119,
    "kind": "variable",
    "name": "zeroWidthSpaceEntity",
    "memberof": "scripts/utils/zeroWidthSpace.js",
    "static": true,
    "longname": "scripts/utils/zeroWidthSpace.js~zeroWidthSpaceEntity",
    "access": "protected",
    "export": false,
    "importPath": "typester/scripts/utils/zeroWidthSpace.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 5,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 120,
    "kind": "variable",
    "name": "zeroWidthSpace",
    "memberof": "scripts/utils/zeroWidthSpace.js",
    "static": true,
    "longname": "scripts/utils/zeroWidthSpace.js~zeroWidthSpace",
    "access": "protected",
    "export": true,
    "importPath": "typester/scripts/utils/zeroWidthSpace.js",
    "importStyle": "zeroWidthSpace",
    "description": "",
    "lineNumber": 10,
    "type": {
      "types": [
        "{\"generate\": function, \"get\": function, \"assert\": function}"
      ]
    }
  },
  {
    "kind": "index",
    "content": "# typester",
    "longname": "/home/fred/Development/TypeCode/typester/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"typester\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"build/js/typester.js\",\n  \"scripts\": {\n    \"test\": \"./node_modules/karma/bin/karma start karma.conf.js\",\n    \"test_ci\": \"NODE_ENV=ci /node_modules/karma/bin/karma start karma.conf.js\",\n    \"test_e2e\": \"cd ./test/e2e && docker-compose run --rm nightwatch\",\n    \"build\": \"rollup -c\",\n    \"watch\": \"./node_modules/.bin/watch \\\"npm run build\\\" src/\",\n    \"docs\": \"./node_modules/.bin/esdoc\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"esdoc\": \"^1.0.4\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"jasmine\": \"^2.6.0\",\n    \"karma\": \"^1.7.0\",\n    \"karma-chrome-launcher\": \"^2.2.0\",\n    \"karma-coverage\": \"^1.1.1\",\n    \"karma-firefox-launcher\": \"^1.0.1\",\n    \"karma-jasmine\": \"^1.1.0\",\n    \"karma-jasmine-jquery\": \"^0.1.1\",\n    \"karma-junit-reporter\": \"^1.2.0\",\n    \"karma-phantomjs-launcher\": \"^1.0.4\",\n    \"karma-rollup-preprocessor\": \"^4.0.0\",\n    \"karma-sourcemap-loader\": \"^0.3.7\",\n    \"karma-spec-reporter\": \"0.0.31\",\n    \"rollup-plugin-buble\": \"^0.16.0\",\n    \"rollup-plugin-istanbul\": \"^1.1.0\"\n  },\n  \"dependencies\": {\n    \"autoprefixer\": \"^6.7.7\",\n    \"babel-core\": \"^6.26.0\",\n    \"babel-plugin-transform-object-rest-spread\": \"^6.23.0\",\n    \"babel-preset-es2015\": \"^6.24.1\",\n    \"babel-preset-es2015-rollup\": \"^3.0.0\",\n    \"dompurify\": \"^1.0.2\",\n    \"postcss\": \"^5.2.16\",\n    \"rollup\": \"^0.50.0\",\n    \"rollup-plugin-babel\": \"^3.0.2\",\n    \"rollup-plugin-commonjs\": \"^8.0.2\",\n    \"rollup-plugin-eslint\": \"^3.0.0\",\n    \"rollup-plugin-handlebars-plus\": \"^0.2.0\",\n    \"rollup-plugin-node-resolve\": \"^3.0.0\",\n    \"rollup-plugin-sass\": \"^0.4.10\",\n    \"watch\": \"^1.0.2\"\n  }\n}\n",
    "longname": "/home/fred/Development/TypeCode/typester/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]
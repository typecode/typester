<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/BaseFormatter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/BaseFormatter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// jshint strict: false

import Module from '../core/Module';
import commands from '../utils/commands';
import DOM from '../utils/DOM';
import zeroWidthSpace from '../utils/zeroWidthSpace';

import toolbarConfig from '../config/toolbar';

let validTags = toolbarConfig.getValidTags();
let blockTags = toolbarConfig.getBlockTags();
let listTags  = toolbarConfig.getListTags();

/**
* @access protected
*/
const BaseFormatter = Module({
    name: 'BaseFormatter',
    props: {},
    handlers: {
        requests: {},
        commands: {
            'format:export:to:canvas': 'exportToCanvas',
            'format:import:from:canvas': 'importFromCanvas',
            'format:default': 'formatDefault',
            'format:clean': 'formatClean'
        },
        events: {
            'contenteditable:newline': 'handleNewLine'
        }
    },
    methods: {
        init () {},

        exportToCanvas () {
            const { mediator } = this;
            const rootElement = mediator.get('selection:rootelement');
            const canvasBody = mediator.get('canvas:body');
            this.injectHooks(rootElement);

            const rangeCoordinates = mediator.get('selection:range:coordinates');
            const clonedNodes = this.cloneNodes(rootElement);
            mediator.exec('canvas:content', clonedNodes);
            mediator.exec('canvas:select:by:coordinates', rangeCoordinates);

            this.removeZeroWidthSpaces(canvasBody);
        },

        cloneNodes (rootElement) {
            let clonedNodes = [];
            rootElement.childNodes.forEach((node) => {
                clonedNodes.push(node.cloneNode(true));
            });
            return clonedNodes;
        },

        injectHooks (rootElement) {
            while (!/\w+/.test(rootElement.firstChild.textContent)) {
                DOM.removeNode(rootElement.firstChild);
            }

            while(!/\w+/.test(rootElement.lastChild.textContent)) {
                DOM.removeNode(rootElement.lastChild);
            }

            DOM.insertBefore(zeroWidthSpace.get(), rootElement.firstChild);
            DOM.insertAfter(zeroWidthSpace.get(), rootElement.lastChild);
        },

        importFromCanvas (opts={}) {
            const { mediator } = this;
            const canvasBody = mediator.get('canvas:body');

            mediator.exec('canvas:cache:selection');
            mediator.exec('format:clean', canvasBody);
            if (opts.importFilter) {
                opts.importFilter(canvasBody);
            }
            mediator.exec('canvas:select:cachedSelection');

            const canvasSelectionCoordinates = mediator.get('canvas:selection:coordinates');
            mediator.exec('selection:select:all');
            mediator.exec('contenteditable:inserthtml', canvasBody.innerHTML);
            mediator.exec('selection:select:coordinates', canvasSelectionCoordinates);

            mediator.emit('import:from:canvas:complete');
        },

        formatDefault () {
            const { mediator } = this;
            const rootElem = mediator.get('selection:rootelement');
            commands.defaultBlockFormat();
            this.removeStyledSpans(rootElem);
        },

        formatEmptyNewLine () {
            const { mediator } = this;
            const anchorNode = mediator.get('selection:anchornode');
            const canDefaultNewline = !(anchorNode.innerText &amp;&amp; anchorNode.innerText.trim().length) &amp;&amp; !DOM.isIn(anchorNode, toolbarConfig.preventNewlineDefault);
            const anchorIsContentEditable = anchorNode.hasAttribute &amp;&amp; anchorNode.hasAttribute('contenteditable');

            if (canDefaultNewline || anchorIsContentEditable) {
                this.formatDefault();
            }
        },

        formateBlockquoteNewLine () {
            const { mediator } = this;

            commands.exec('outdent');
            this.formatDefault();

            const currentRangeClone = mediator.get('selection:range').cloneRange();
            const { startContainer } = currentRangeClone;

            if (startContainer.previousSibling &amp;&amp; startContainer.previousSibling.nodeName === 'BLOCKQUOTE') {
                const brEls = startContainer.previousSibling.querySelectorAll('br');
                const divEls = startContainer.previousSibling.querySelectorAll('div');

                for (let i = 0; i &lt; brEls.length; i++) {
                    DOM.removeNode(brEls[i]);
                }

                for (let i = 0; i &lt; divEls.length; i++) {
                    DOM.unwrap(divEls[i]);
                }

                mediator.exec('selection:update:range', currentRangeClone);
            }

        },

        handleNewLine () {
            const { mediator } = this;
            const { startContainer } = mediator.get('selection:range');
            const containerIsEmpty = !/\w+/.test(startContainer.textContent);
            const containerIsBlockquote = DOM.isIn(startContainer, 'BLOCKQUOTE');
            const isContentEditable = startContainer.nodeType === Node.ELEMENT_NODE &amp;&amp; startContainer.hasAttribute('contenteditable');

            if (containerIsBlockquote) {
                this.formateBlockquoteNewLine();
            } else if (containerIsEmpty || isContentEditable) {
                this.formatEmptyNewLine();
            }
        },

        formatClean (rootElem) {
            this.unwrapInvalidElements(rootElem);
            this.defaultOrphanedTextNodes(rootElem);
            this.removeBrNodes(rootElem);
            this.ensureRootElems(rootElem);
            this.removeStyleAttributes(rootElem);
            this.removeEmptyNodes(rootElem, { recursive: true });

            // -----

            // this.removeBrNodes(rootElem);
            // // this.removeEmptyNodes(rootElem);
            // this.removeFontTags(rootElem);
            // this.removeStyledSpans(rootElem);
            // this.clearEntities(rootElem);
            // this.removeZeroWidthSpaces(rootElem);
            // this.defaultOrphanedTextNodes(rootElem);
            // this.removeEmptyNodes(rootElem, { recursive: true });
        },

        removeStyleAttributes (rootElem) {
            const styleAttributeNodes = rootElem.querySelectorAll('[style]');
            styleAttributeNodes.forEach((styleAttributeNode) => {
                styleAttributeNode.removeAttribute('style');
            });
        },

        removeBrNodes (rootElem) {
            const brNodes = rootElem.querySelectorAll('br');
            let brNodesToProcess = [];
            let brNodesToRemove = [];

            brNodes.forEach((brNode) => {
                const skipNode = brNode.skipNode;

                if (skipNode) {
                    return;
                }

                const isLastChild = brNode === brNode.parentNode.lastChild;
                const isDoubleBreak = brNode.nextSibling &amp;&amp; brNode.nextSibling.nodeName === 'BR';
                const isInBlock = DOM.isIn(brNode, blockTags, rootElem);

                if (isLastChild) {
                    brNodesToRemove.push(isLastChild);
                    return;
                }

                if (isDoubleBreak &amp;&amp; isInBlock) {
                    brNodesToProcess.push([
                        brNode,
                        brNode.nextSibling
                    ]);
                    brNode.nextSibling.skipNode = true;
                    return;
                }
            });

            brNodesToProcess.forEach((brNodePair) => {
                const [firstBrNode, secondBrNode] = brNodePair;
                const closestBlock = DOM.getClosestInArray(firstBrNode, blockTags, rootElem);
                const newParagraph = document.createElement('p');
                let previousSibling;

                while ((previousSibling = firstBrNode.previousSibling)) {
                    if (newParagraph.firstChild) {
                        DOM.insertBefore(previousSibling, newParagraph.firstChild);
                    } else {
                        newParagraph.appendChild(previousSibling);
                    }

                    DOM.insertBefore(newParagraph, closestBlock);
                }

                DOM.removeNode(firstBrNode);
                DOM.removeNode(secondBrNode);
            });

            brNodesToRemove.forEach((brNode) => {
                DOM.removeNode(brNode);
            });
        },

        unwrapInvalidElements (rootElem) {
            const rootDoc = rootElem.ownerDocument;
            const walker = rootDoc.createTreeWalker(
                rootElem,
                NodeFilter.SHOW_ELEMENT,
                null,
                false
            );

            let invalidElements = [];
            while (walker.nextNode()) {
                let { currentNode } = walker;
                let isInvalid = validTags.indexOf(currentNode.nodeName) &lt; 0;
                let isBrNode = currentNode.nodeName === 'BR'; // BR nodes are handled elsewhere
                let isTypesterElem = currentNode.className &amp;&amp; /typester/.test(currentNode.className);

                if (isInvalid &amp;&amp; !isBrNode &amp;&amp; !isTypesterElem) {
                    invalidElements.unshift(currentNode);
                }
            }

            invalidElements.forEach((invalidElement) => {
                let unwrappedNodes = DOM.unwrap(invalidElement, { keepNode: true });
                if (!DOM.isIn(invalidElement, validTags, rootElem) &amp;&amp; unwrappedNodes.length) {
                    let newParagraph = rootDoc.createElement('p');
                    unwrappedNodes.forEach((unwrappedNode) => {
                        newParagraph.appendChild(unwrappedNode);
                    });
                    DOM.insertBefore(newParagraph, invalidElement);
                }
                DOM.removeNode(invalidElement);
            });
        },

        defaultOrphanedTextNodes (rootElem) {
            const { childNodes } = rootElem;
            for (let i = 0; i &lt; childNodes.length; i++) {
                let childNode = childNodes[i];
                if (childNode.nodeType === Node.TEXT_NODE &amp;&amp; /\w+/.test(childNode.textContent)) {
                    let newParagraph = document.createElement('p');
                    DOM.insertBefore(newParagraph, childNode);
                    newParagraph.appendChild(childNode);
                    while (newParagraph.nextSibling &amp;&amp; blockTags.concat(listTags).indexOf(newParagraph.nextSibling.nodeName) &lt; 0) {
                        newParagraph.appendChild(newParagraph.nextSibling);
                    }
                }
            }
        },

        clearEntities (rootElem) {
            const rootDoc = rootElem.ownerDocument;
            const walker = rootDoc.createTreeWalker(
                rootElem,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let textNodes = [];
            while(walker.nextNode()) {
                textNodes.push(walker.currentNode);
            }

            textNodes.forEach((textNode) => {
                if (/\w+/.test(textNode.textContent)) {
                    textNode.nodeValue = textNode.nodeValue.replace(/^\u00a0/, '');
                    textNode.nodeValue = textNode.nodeValue.replace(/\u00a0$/, '');
                }
            });
        },

        ensureRootElems (rootElem) {
            const rootNodeTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'OL', 'UL', 'BLOCKQUOTE', 'P'];
            const nestableTags = [
                {
                    tags: ['OL', 'UL'],
                    validParents: ['OL', 'UL', 'LI']
                },
                {
                    tags: ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'],
                    validParents: ['LI']
                }
            ];
            const rootNodes = rootElem.querySelectorAll(rootNodeTags.join(', '));
            const validNesting = function (node) {
                let validNesting = false;
                nestableTags.forEach((nestingDict) => {
                    if (
                        nestingDict.tags.indexOf(node.tagName) > -1 &amp;&amp;
                        nestingDict.validParents.indexOf(node.parentNode.tagName) > -1
                    ) {
                        validNesting = true;
                    }
                });
                return validNesting;
            };

            const moveNodeToRoot = function (node) {
                if (
                    node.parentNode === rootElem
                ) {
                    return;
                }

                if (validNesting(node)) {
                    return;
                }

                let rootParentNode = node.parentNode;
                if (node.tagName === 'P' &amp;&amp; ['LI', 'BLOCKQUOTE'].indexOf(rootParentNode.tagName) > -1) {
                    while (node.firstChild) {
                        DOM.insertBefore(node.firstChild, node);
                    }
                    DOM.removeNode(node);
                    return;
                }

                while (
                    rootParentNode.parentNode !== rootElem
                ) {
                    rootParentNode = rootParentNode.parentNode;
                }

                DOM.insertBefore(node, rootParentNode);
            };

            rootNodes.forEach(moveNodeToRoot);
        },

        removeZeroWidthSpaces (rootElem) {
            rootElem.childNodes.forEach((childNode) => {
                if (
                    childNode.nodeType === Node.TEXT_NODE &amp;&amp;
                    zeroWidthSpace.assert(childNode)
                ) {
                    DOM.removeNode(childNode);
                }
            });
        },

        removeEmptyNodes (rootElem, opts={}) {
            if (rootElem.normalize) {
                rootElem.normalize();
            }

            for (let i = rootElem.childNodes.length - 1; i >= 0; i--) {
                let childNode = rootElem.childNodes[i];

                if (childNode.nodeName === 'BR') {
                    continue;
                }

                if (opts.recursive &amp;&amp; childNode.childNodes.length) {
                    this.removeEmptyNodes(childNode, { recursive: true, rootIsChild: true });
                }

                if (!/[\w\.,\/#!$%\^&amp;\*;:{}=\-_`~()\'\"]/.test(childNode.textContent)) {
                    if (
                        (!opts.rootIsChild &amp;&amp; !zeroWidthSpace.assert(childNode) &amp;&amp; i > 0) ||
                        childNode.nodeType === Node.ELEMENT_NODE
                    ) {
                        DOM.removeNode(childNode);
                    }
                }
            }
        },

        removeStyledSpans (rootElem) {
            const styledSpans = rootElem.querySelectorAll('span[style]');
            for (let i = styledSpans.length - 1; i >= 0; i--) {
                let styledSpan = styledSpans[i];
                while (styledSpan.firstChild) {
                    DOM.insertBefore(styledSpan.firstChild, styledSpan);
                }
                DOM.removeNode(styledSpan);
            }
        },

        removeFontNodes (rootElem) {
            const fontTags = rootElem.querySelectorAll('font');
            for (let i = fontTags.length - 1; i >= 0; i--) {
                let fontTag = fontTags[i];
                while (fontTag.firstChild) {
                    DOM.insertBefore(fontTag.firstChild, fontTag);
                }
                DOM.removeNode(fontTag);
            }
        }
    }
});

export default BaseFormatter;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-containers_AppContainer.html">containers/AppContainer</a></li><li><a href="module-containers_CanvasContainer.html">containers/CanvasContainer</a></li><li><a href="module-containers_FormatterContainer.html">containers/FormatterContainer</a></li><li><a href="module-containers_UIContainer.html">containers/UIContainer</a></li><li><a href="module-core_Container.html">core/Container</a></li><li><a href="module-core_Context.html">core/Context</a></li><li><a href="module-core_Mediator.html">core/Mediator</a></li><li><a href="module-modules_ContentEditable.html">modules/ContentEditable</a></li><li><a href="module-modules_Selection.html">modules/Selection</a></li></ul><h3>Classes</h3><ul><li><a href="module-containers_AppContainer-AppContainer.html">AppContainer</a></li><li><a href="module-containers_CanvasContainer-CanvasContainer.html">CanvasContainer</a></li><li><a href="module-containers_FormatterContainer-FormatterContainer.html">FormatterContainer</a></li><li><a href="module-containers_UIContainer-UIContainer.html">UIContainer</a></li><li><a href="module-core_Context-Context.html">Context</a></li><li><a href="module-core_Mediator-Mediator.html">Mediator</a></li><li><a href="module-modules_ContentEditable-ContentEditable.html">ContentEditable</a></li><li><a href="module-modules_Selection-Selection.html">Selection</a></li></ul><h3>Events</h3><ul><li><a href="module-modules_ContentEditable.html#~event:contenteditable:focus">contenteditable:focus</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-core_Mediator-Mediator-requests.html">requests</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BaseFormatter">BaseFormatter</a></li><li><a href="global.html#BlockFormatter">BlockFormatter</a></li><li><a href="global.html#browser">browser</a></li><li><a href="global.html#Canvas">Canvas</a></li><li><a href="global.html#commands">commands</a></li><li><a href="global.html#DOM">DOM</a></li><li><a href="global.html#Flyout">Flyout</a></li><li><a href="global.html#Formatter">Formatter</a></li><li><a href="global.html#formatters">formatters</a></li><li><a href="global.html#func">func</a></li><li><a href="global.html#guid">guid</a></li><li><a href="global.html#keycodes">keycodes</a></li><li><a href="global.html#LinkFormatter">LinkFormatter</a></li><li><a href="global.html#ListFormatter">ListFormatter</a></li><li><a href="global.html#Module">Module</a></li><li><a href="global.html#Mouse">Mouse</a></li><li><a href="global.html#Paste">Paste</a></li><li><a href="global.html#pasteUtils">pasteUtils</a></li><li><a href="global.html#TextFormatter">TextFormatter</a></li><li><a href="global.html#Toolbar">Toolbar</a></li><li><a href="global.html#Typester">Typester</a></li><li><a href="global.html#zeroWidthSpace">zeroWidthSpace</a></li><li><a href="global.html#zeroWidthSpaceEntity">zeroWidthSpaceEntity</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Jan 09 2018 21:24:57 GMT+0200 (SAST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
